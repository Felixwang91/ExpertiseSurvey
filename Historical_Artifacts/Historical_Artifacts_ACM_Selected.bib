
@inproceedings{hannebauer_automatically_2016,
	title = {Automatically recommending code reviewers based on their expertise: an empirical comparison},
	isbn = {978-1-4503-3845-5},
	shorttitle = {Automatically recommending code reviewers based on their expertise},
	url = {http://dl.acm.org/citation.cfm?doid=2970276.2970306},
	doi = {10.1145/2970276.2970306},
	language = {en},
	urldate = {2018-03-20},
	publisher = {ACM Press},
	author = {Hannebauer, Christoph and Patalas, Michael and St√ºnkel, Sebastian and Gruhn, Volker},
	year = {2016},
	pages = {99--110}
}

@inproceedings{beller_modern_2014,
	title = {Modern code reviews in open-source projects: which problems do they fix?},
	isbn = {978-1-4503-2863-0},
	shorttitle = {Modern code reviews in open-source projects},
	url = {http://dl.acm.org/citation.cfm?doid=2597073.2597082},
	doi = {10.1145/2597073.2597082},
	language = {en},
	urldate = {2018-03-20},
	publisher = {ACM Press},
	author = {Beller, Moritz and Bacchelli, Alberto and Zaidman, Andy and Juergens, Elmar},
	year = {2014},
	pages = {202--211}
}

@inproceedings{thongtanunam_improving_2014,
	address = {New York, NY, USA},
	series = {{CHASE} 2014},
	title = {Improving {Code} {Review} {Effectiveness} {Through} {Reviewer} {Recommendations}},
	isbn = {978-1-4503-2860-9},
	url = {http://doi.acm.org/10.1145/2593702.2593705},
	doi = {10.1145/2593702.2593705},
	abstract = {Effectively performing code review increases the quality of software and reduces occurrence of defects. However, this requires reviewers with experiences and deep understandings of system code. Manual selection of such reviewers can be a costly and time-consuming task. To reduce this cost, we propose a reviewer recommendation algorithm determining file path similarity called FPS algorithm. Using three OSS projects as case studies, FPS algorithm was accurate up to 77.97\%, which significantly outperformed the previous approach.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 7th {International} {Workshop} on {Cooperative} and {Human} {Aspects} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Thongtanunam, Patanamon and Kula, Raula Gaikovina and Cruz, Ana Erika Camargo and Yoshida, Norihiro and Iida, Hajimu},
	year = {2014},
	keywords = {Open Source Software, Peer Code Review, Recommendation System, Software Quality},
	pages = {119--122},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/F633CPD3/Thongtanunam et al. - 2014 - Improving Code Review Effectiveness Through Review.pdf:application/pdf}
}

@inproceedings{schilling_train_2012,
	address = {New York, NY, USA},
	series = {{SIGMIS}-{CPR} '12},
	title = {Train and {Retain}: {The} {Impact} of {Mentoring} on the {Retention} of {FLOSS} {Developers}},
	isbn = {978-1-4503-1110-6},
	shorttitle = {Train and {Retain}},
	url = {http://doi.acm.org/10.1145/2214091.2214112},
	doi = {10.1145/2214091.2214112},
	abstract = {The acquisition of new knowledge is a critical task for software development. IT companies spend considerable resources in the training of their employees to succeed in a continuously changing industry. Depending on the voluntary commitment of their contributors, initiatives developing Free Libre Open Source Software (FLOSS) identified members' learning and their retention as vital. Although contributors' knowledge building has been repeatedly found to facilitate their project continuance, FLOSS projects are lacking operational advices on how to assist their members' learning. Drawing on previous literature which emphasizes project members' social interactions and their practical experiences to build new knowledge, we propose mentoring as a training method for FLOSS projects. Based on organizational experiences, we propose a measure to evaluate mentoring as an appropriate strategy for FLOSS initiatives to facilitate individuals' learning and to retain their contributors on longitudinal base.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 50th {Annual} {Conference} on {Computers} and {People} {Research}},
	publisher = {ACM},
	author = {Schilling, Andreas and Laumer, Sven and Weitzel, Tim},
	year = {2012},
	keywords = {free libre open source software, knowledge building, mentoring, open source software development, retention, turnover behavior},
	pages = {79--84},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/TEMZE5LP/Schilling et al. - 2012 - Train and Retain The Impact of Mentoring on the R.pdf:application/pdf}
}

@inproceedings{alonso_expertise_2008,
	address = {New York, NY, USA},
	series = {{MSR} '08},
	title = {Expertise {Identification} and {Visualization} from {CVS}},
	isbn = {978-1-60558-024-1},
	url = {http://doi.acm.org/10.1145/1370750.1370780},
	doi = {10.1145/1370750.1370780},
	abstract = {As software evolves over time, the identification of expertise becomes an important problem. Component ownership and team awareness of such ownership are signals of solid project. Ownership and ownership awareness are also issues in open-source software (OSS) projects. Indeed, the membership in OSS projects is dynamic with team members arriving and leaving. In large open source projects, specialists who know the system very well are considered experts. How can one identify the experts in a project by mining a particular repository like the source code? Have they gotten help from other people? We provide an approach using classification of the source code tree as a path to derive the expertise of the committers. Because committers may get help from other people, we also retrieve their contributors. We also provide a visualization that helps to further explore the repository via committers and categories. We present a prototype implementation that describes our research using the Apache HTTP Web server project as a case study.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2008 {International} {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Alonso, Omar and Devanbu, Premkumar T. and Gertz, Michael},
	year = {2008},
	keywords = {classification, expertise identification, information visualization, open source},
	pages = {125--128},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/8DB6J42L/Alonso et al. - 2008 - Expertise Identification and Visualization from CV.pdf:application/pdf}
}

@inproceedings{greene_cvexplorer:_2016,
	address = {New York, NY, USA},
	series = {{ASE} 2016},
	title = {{CVExplorer}: {Identifying} {Candidate} {Developers} by {Mining} and {Exploring} {Their} {Open} {Source} {Contributions}},
	isbn = {978-1-4503-3845-5},
	shorttitle = {{CVExplorer}},
	url = {http://doi.acm.org/10.1145/2970276.2970285},
	doi = {10.1145/2970276.2970285},
	abstract = {Open source code contributions contain a large amount of technical skill information about developers, which can help to identify suitable candidates for a particular development job and therefore impact the success of a development team. We develop CVExplorer as a tool to extract, visualize, and explore relevant technical skills data from GitHub, such as languages and libraries used. It allows non-technical users to filter and identify developers according to technical skills demonstrated across all of their open source contributions, in order to support more accurate candidate identification. We demonstrate the usefulness of CVExplorer by using it to recommend candidates for open positions in two companies.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 31st {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {ACM},
	author = {Greene, Gillian J. and Fischer, Bernd},
	year = {2016},
	keywords = {Developer skills identification, Identifying candidate developers, Mining software repositories},
	pages = {804--809},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/S5VWNB5C/Greene and Fischer - 2016 - CVExplorer Identifying Candidate Developers by Mi.pdf:application/pdf}
}

@inproceedings{fritz_degree--knowledge_2010,
	address = {New York, NY, USA},
	series = {{ICSE} '10},
	title = {A {Degree}-of-knowledge {Model} to {Capture} {Source} {Code} {Familiarity}},
	isbn = {978-1-60558-719-6},
	url = {http://doi.acm.org/10.1145/1806799.1806856},
	doi = {10.1145/1806799.1806856},
	abstract = {The size and high rate of change of source code comprising a software system make it difficult for software developers to keep up with who on the team knows about particular parts of the code. Existing approaches to this problem are based solely on authorship of code. In this paper, we present data from two professional software development teams to show that both authorship and interaction information about how a developer interacts with the code are important in characterizing a developer's knowledge of code. We introduce the degree-of-knowledge model that computes automatically a real value for each source code element based on both authorship and interaction information. We show that the degree-of-knowledge model can provide better results than an existing expertise finding approach and also report on case studies of the use of the model to support knowledge transfer and to identify changes of interest.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 32Nd {ACM}/{IEEE} {International} {Conference} on {Software} {Engineering} - {Volume} 1},
	publisher = {ACM},
	author = {Fritz, Thomas and Ou, Jingwen and Murphy, Gail C. and Murphy-Hill, Emerson},
	year = {2010},
	keywords = {authorship, degree-of-interest, degree-of-knowledge, expertise, interaction, onboarding, recommendation},
	pages = {385--394},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/36SX6SXA/Fritz et al. - 2010 - A Degree-of-knowledge Model to Capture Source Code.pdf:application/pdf}
}

@inproceedings{bosu_impact_2014,
	address = {New York, NY, USA},
	series = {{ESEM} '14},
	title = {Impact of {Developer} {Reputation} on {Code} {Review} {Outcomes} in {OSS} {Projects}: {An} {Empirical} {Investigation}},
	isbn = {978-1-4503-2774-9},
	shorttitle = {Impact of {Developer} {Reputation} on {Code} {Review} {Outcomes} in {OSS} {Projects}},
	url = {http://doi.acm.org/10.1145/2652524.2652544},
	doi = {10.1145/2652524.2652544},
	abstract = {{\textless}u{\textgreater}Context:{\textless}/u{\textgreater} Gaining an identity and building a good reputation are important motivations for Open Source Software (OSS) developers. It is unclear whether these motivations have any actual impact on OSS project success. {\textless}u{\textgreater}Goal:{\textless}/u{\textgreater} To identify how an OSS developer's reputation affects the outcome of his/her code review requests. {\textless}u{\textgreater}Method:{\textless}/u{\textgreater} We conducted a social network analysis (SNA) of the code review data from eight popular OSS projects. Working on the assumption that core developers have better reputation than peripheral developers, we developed an approach, Core Identification using K-means (CIK) to divide the OSS developers into core and periphery groups based on six SNA centrality measures. We then compared the outcome of the code review process for members of the two groups. {\textless}u{\textgreater}Results:{\textless}/u{\textgreater} The results suggest that the core developers receive quicker first feedback on their review request, complete the review process in shorter time, and are more likely to have their code changes accepted into the project codebase. Peripheral developers may have to wait 2 - 19 times (or 12 - 96 hours) longer than core developers for the review process of their code to complete. {\textless}u{\textgreater}Conclusion:{\textless}/u{\textgreater} We recommend that projects allocate resources or create tool support to triage the code review requests to motivate prospective developers through quick feedback.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 8th {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement}},
	publisher = {ACM},
	author = {Bosu, Amiangshu and Carver, Jeffrey C.},
	year = {2014},
	keywords = {code review, network structure, open source, peer impression, social network analysis},
	pages = {33:1--33:10},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/5C6JB65Y/Bosu and Carver - 2014 - Impact of Developer Reputation on Code Review Outc.pdf:application/pdf}
}

@inproceedings{rahman_correct:_2016,
	address = {New York, NY, USA},
	series = {{ICSE} '16},
	title = {{CoRReCT}: {Code} {Reviewer} {Recommendation} in {GitHub} {Based} on {Cross}-project and {Technology} {Experience}},
	isbn = {978-1-4503-4205-6},
	shorttitle = {{CoRReCT}},
	url = {http://doi.acm.org/10.1145/2889160.2889244},
	doi = {10.1145/2889160.2889244},
	abstract = {Peer code review locates common coding rule violations and simple logical errors in the early phases of software development, and thus reduces overall cost. However, in GitHub, identifying an appropriate code reviewer for a pull request is a non-trivial task given that reliable information for reviewer identification is often not readily available. In this paper, we propose a code reviewer recommendation technique that considers not only the relevant cross-project work history (e.g., external library experience) but also the experience of a developer in certain specialized technologies associated with a pull request for determining her expertise as a potential code reviewer. We first motivate our technique using an exploratory study with 10 commercial projects and 10 associated libraries external to those projects. Experiments using 17,115 pull requests from 10 commercial projects and six open source projects show that our technique provides 85\%-- 92\% recommendation accuracy, about 86\% precision and 79\%--81\% recall in code reviewer recommendation, which are highly promising. Comparison with the state-of-the-art technique also validates the empirical findings and the superiority of our recommendation technique.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering} {Companion}},
	publisher = {ACM},
	author = {Rahman, Mohammad Masudur and Roy, Chanchal K. and Collins, Jason A.},
	year = {2016},
	keywords = {code reviewer recommendation, cross-project experience, GitHub, pull request, specialized technology experience},
	pages = {222--231},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/CQ2V46S3/Rahman et al. - 2016 - CoRReCT Code Reviewer Recommendation in GitHub Ba.pdf:application/pdf}
}

@inproceedings{venkataramani_discovery_2013,
	address = {New York, NY, USA},
	series = {{WWW} '13 {Companion}},
	title = {Discovery of {Technical} {Expertise} from {Open} {Source} {Code} {Repositories}},
	isbn = {978-1-4503-2038-2},
	url = {http://doi.acm.org/10.1145/2487788.2487832},
	doi = {10.1145/2487788.2487832},
	abstract = {Online Question and Answer websites for developers have emerged as the main forums for interaction during the software development process. The veracity of an answer in such websites is typically verified by the number of 'upvotes' that the answer garners from peer programmers using the same forum. Although this mechanism has proved to be extremely successful in rating the usefulness of the answers, it does not lend itself very elegantly to model the expertise of a user in a particular domain. In this paper, we propose a model to rank the expertise of the developers in a target domain by mining their activity in different opensource projects. To demonstrate the validity of the model, we built a recommendation system for StackOverflow which uses the data mined from GitHub.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 22Nd {International} {Conference} on {World} {Wide} {Web}},
	publisher = {ACM},
	author = {Venkataramani, Rahul and Gupta, Atul and Asadullah, Allahbaksh and Muddu, Basavaraju and Bhat, Vasudev},
	year = {2013},
	keywords = {github, knowledge discovery, recommendations, source code repository, stackoverflow, technical expertise},
	pages = {97--98},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/WVEY98RU/Venkataramani et al. - 2013 - Discovery of Technical Expertise from Open Source .pdf:application/pdf;ACM Full Text PDF:/Users/Felix/Zotero/storage/H3MHM586/Venkataramani et al. - 2013 - Discovery of Technical Expertise from Open Source .pdf:application/pdf}
}

@inproceedings{sindhgatta_identifying_2008,
	address = {New York, NY, USA},
	series = {{KDD} '08},
	title = {Identifying {Domain} {Expertise} of {Developers} from {Source} {Code}},
	isbn = {978-1-60558-193-4},
	url = {http://doi.acm.org/10.1145/1401890.1402007},
	doi = {10.1145/1401890.1402007},
	abstract = {We are interested in identifying the domain expertise of developers of a software system. A developer gains expertise on the code base as well as the domain of the software system he/she develops. This information forms a useful input in allocating software implementation tasks to developers. Domain concepts represented by the system are discovered by taking into account the linguistic information available in the source code. The vocabulary contained in source code as identifiers such as class, method, variable names and comments are extracted. Concepts present in the code base are identified and grouped based on a well known text processing hypothesis - words are similar to the extent to which they share similar words. The developer's association with the source code and the concepts it represents is arrived at using the version repository information. In this line, the analysis first derives documents from source code by discarding all the programming language constructs. KMeans clustering is further used to cluster documents and extract closely related concepts. The key concepts present in the documents authored by the developer determine his/her domain expertise. To validate our approach we apply it on large software systems, two of which are presented in detail in this paper.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 14th {ACM} {SIGKDD} {International} {Conference} on {Knowledge} {Discovery} and {Data} {Mining}},
	publisher = {ACM},
	author = {Sindhgatta, Renuka},
	year = {2008},
	keywords = {developer expertise, document clustering, version history},
	pages = {981--989},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/FUB7UYHL/Sindhgatta - 2008 - Identifying Domain Expertise of Developers from So.pdf:application/pdf}
}

@inproceedings{moraes_recommending_2010,
	address = {New York, NY, USA},
	series = {{RSSE} '10},
	title = {Recommending {Experts} {Using} {Communication} {History}},
	isbn = {978-1-60558-974-9},
	url = {http://doi.acm.org/10.1145/1808920.1808929},
	doi = {10.1145/1808920.1808929},
	abstract = {In distributed software development the communication is inefficient because of geographical and temporal distances, affecting the team's performance and awareness. The low level of awareness makes hard the task of finding the expert of a piece of source code, delaying the implementation whenever a developer needs help. To identify and to recommend the people with right knowledge to people in trouble during the implementation can improve the collaboration and awareness of the team because it can reduce the waiting time for an answer, since the expert can be contacted directly. In this paper we propose recommender system for expert location with the aim to reduce delays of finding the right person whenever somebody needs assistance during coding. Our approach uses the communication history of the project (the developer's mailing list) in addition to usual source code history. We also present results which show the practical potential of our approach.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2Nd {International} {Workshop} on {Recommendation} {Systems} for {Software} {Engineering}},
	publisher = {ACM},
	author = {Moraes, Alan and Silva, Eduardo and da Trindade, Cleyton and Barbosa, Yuri and Meira, Silvio},
	year = {2010},
	keywords = {distributed software development, expert recommender system, global software engineering, knowledge management},
	pages = {41--45},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/ZZPWSZ4D/Moraes et al. - 2010 - Recommending Experts Using Communication History.pdf:application/pdf}
}

@inproceedings{gupta_nirikshan:_2014,
	address = {New York, NY, USA},
	series = {{ICSE} {Companion} 2014},
	title = {Nirikshan: {Process} {Mining} {Software} {Repositories} to {Identify} {Inefficiencies}, {Imperfections}, and {Enhance} {Existing} {Process} {Capabilities}},
	isbn = {978-1-4503-2768-8},
	shorttitle = {Nirikshan},
	url = {http://doi.acm.org/10.1145/2591062.2591080},
	doi = {10.1145/2591062.2591080},
	abstract = {Process mining is to extract knowledge about business processes from data stored implicitly in ad-hoc way or explicitly by information systems. The aim is to discover runtime process, analyze performance and perform conformance verification, using process mining tools like ProM and Disco, for single software repository and processes spanning across multiple repositories. Application of process mining to software repositories has recently gained interest due to availability of vast data generated during software development and maintenance. Process data are embodied in repositories which can be used for analysis to improve the efficiency and capability of process, however, involves a lot of challenges which have not been addressed so far. Project team defines workflow, design process and policies for tasks like issue tracking (defect or feature enhancement), peer code review (review the submitted patch to avoid defects before they are injected) etc. to streamline and structure the activities. The reality may not be the same as defined because of imperfections so the extent of non-conformance needs to be measured. We propose a research framework `Nirikshan' to process mine the data of software repositories from multiple perspectives like process, organizational, data and time. We apply process mining on software repositories to derive runtime process map, identify and remove inefficiencies and imperfections, extend the capabilities of existing software engineering tools to make them more process aware, and understand interaction pattern between various contributors to improve the efficiency of project.},
	urldate = {2018-03-20},
	booktitle = {Companion {Proceedings} of the 36th {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Gupta, Monika},
	year = {2014},
	keywords = {Business Process Intelligence, Empirical Software Engineering and Measurements, Mining Software Repositories, Open-Source Software, Process Mining},
	pages = {658--661},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/B9QLULFB/Gupta - 2014 - Nirikshan Process Mining Software Repositories to.pdf:application/pdf}
}

@article{fritz_degree--knowledge:_2014,
	title = {Degree-of-knowledge: {Modeling} a {Developer}'s {Knowledge} of {Code}},
	volume = {23},
	issn = {1049-331X},
	shorttitle = {Degree-of-knowledge},
	url = {http://doi.acm.org/10.1145/2512207},
	doi = {10.1145/2512207},
	abstract = {As a software system evolves, the system's codebase constantly changes, making it difficult for developers to answer such questions as who is knowledgeable about particular parts of the code or who needs to know about changes made. In this article, we show that an externalized model of a developer's individual knowledge of code can make it easier for developers to answer such questions. We introduce a degree-of-knowledge model that computes automatically, for each source-code element in a codebase, a real value that represents a developer's knowledge of that element based on a developer's authorship and interaction data. We present evidence that shows that both authorship and interaction data of the code are important in characterizing a developer's knowledge of code. We report on the usage of our model in case studies on expert finding, knowledge transfer, and identifying changes of interest. We show that our model improves upon an existing expertise-finding approach and can accurately identify changes for which a developer should likely be aware. We discuss how our model may provide a starting point for knowledge transfer but that more refinement is needed. Finally, we discuss the robustness of the model across multiple development sites.},
	number = {2},
	urldate = {2018-03-20},
	journal = {ACM Trans. Softw. Eng. Methodol.},
	author = {Fritz, Thomas and Murphy, Gail C. and Murphy-Hill, Emerson and Ou, Jingwen and Hill, Emily},
	month = apr,
	year = {2014},
	keywords = {Authorship, degree-of-interest, degree-of-knowledge, development environment, expertise, onboarding, recommendation},
	pages = {14:1--14:42},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/56EGUJEY/Fritz et al. - 2014 - Degree-of-knowledge Modeling a Developer's Knowle.pdf:application/pdf}
}

@inproceedings{teyton_automatic_2014,
	address = {New York, NY, USA},
	series = {{EASE} '14},
	title = {Automatic {Extraction} of {Developer} {Expertise}},
	isbn = {978-1-4503-2476-2},
	url = {http://doi.acm.org/10.1145/2601248.2601266},
	doi = {10.1145/2601248.2601266},
	abstract = {Context: Expert identification is becoming critical to ease the communication between developers in case of global software development or to better know members of large software communities. To quickly identify who are the experts that will best perform a given development task, both the assignment of skills to developers and the computation of their corresponding expertise level have to be automated. Since the real level of expertise is tedious to assess, our challenge is to identify developers having a significant level of experience with respect to a skill. Method: In this paper we propose XTic, an approach that takes up this challenge with the intent to be accurate and efficient. XTic provides a language to specify skills. It also provides an automatic process that extracts skills and experience levels from source code repositories. Our approach is based on the idea that an expert has a high level of experience with respect to a skill. Results: We have validated XTic both on open source and industrial projects to measure its accuracy and its efficiency. The results we obtained show that its accuracy is between moderate and strong and that it scales well with medium and large size software projects. Conclusion: XTic supports the specification of a diversity of developer skills and the extraction of the expertise of these developers under the form of level of experience.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 18th {International} {Conference} on {Evaluation} and {Assessment} in {Software} {Engineering}},
	publisher = {ACM},
	author = {Teyton, C√©dric and Palyart, Marc and Falleri, Jean-R√©my and Morandat, Flor√©al and Blanc, Xavier},
	year = {2014},
	keywords = {software maintenance, software repositories, team communication},
	pages = {8:1--8:10},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/2HRIV6YJ/Teyton et al. - 2014 - Automatic Extraction of Developer Expertise.pdf:application/pdf;ACM Full Text PDF:/Users/Felix/Zotero/storage/RXYVBXGR/Teyton et al. - 2014 - Automatic Extraction of Developer Expertise.pdf:application/pdf}
}

@inproceedings{rahman_correct:_2016-1,
	address = {New York, NY, USA},
	series = {{ASE} 2016},
	title = {{CORRECT}: {Code} {Reviewer} {Recommendation} at {GitHub} for {Vendasta} {Technologies}},
	isbn = {978-1-4503-3845-5},
	shorttitle = {{CORRECT}},
	url = {http://doi.acm.org/10.1145/2970276.2970283},
	doi = {10.1145/2970276.2970283},
	abstract = {Peer code review locates common coding standard violations and simple logical errors in the early phases of software development, and thus, reduces overall cost. Unfortunately, at GitHub, identifying an appropriate code reviewer for a pull request is challenging given that reliable information for reviewer identification is often not readily available. In this paper, we propose a code reviewer recommendation tool-CORRECT-that considers not only the relevant cross-project work experience (e.g., external library experience) of a developer but also her experience in certain specialized technologies (e.g., Google App Engine) associated with a pull request for determining her expertise as a potential code reviewer. We design our tool using client-server architecture, and then package the solution as a Google Chrome plug-in. Once the developer initiates a new pull request at GitHub, our tool automatically analyzes the request, mines two relevant histories, and then returns a ranked list of appropriate code reviewers for the request within the browser's context. Demo: https://www.youtube.com/watch?v=rXU1wTD6QQ0},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 31st {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {ACM},
	author = {Rahman, Mohammad Masudur and Roy, Chanchal K. and Redl, Jesse and Collins, Jason A.},
	year = {2016},
	keywords = {Code reviewer recommendation, cross-project experience, GitHub, pull request, specialized technology experience},
	pages = {792--797},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/MLEW7RWG/Rahman et al. - 2016 - CORRECT Code Reviewer Recommendation at GitHub fo.pdf:application/pdf}
}

@inproceedings{allaho_increasing_2014,
	address = {New York, NY, USA},
	series = {{CIKM} '14},
	title = {Increasing the {Responsiveness} of {Recommended} {Expert} {Collaborators} for {Online} {Open} {Projects}},
	isbn = {978-1-4503-2598-1},
	url = {http://doi.acm.org/10.1145/2661829.2662032},
	doi = {10.1145/2661829.2662032},
	abstract = {We consider the experts recommendation problem for open collaborative projects in large-scale Open Source Software (OSS) communities. In large-scale online community, recommending expert collaborators to a project coordinator or lead developer has two prominent challenges: (i) the "cold shoulder"' problem, which is the lack of interest from the experts to collaborate and share their skills, and (ii) the "cold start" problem, which is an issue with community members who has scarce data history. In this paper, we consider the Degree of Knowledge (DoK) which imposes the knowledge of the skills factor, and the Social Relative Importance (SRI) which imposes the social distance factor to tackle the aforementioned challenges. We propose four DoK models and integrate them with three SRI methods under our proposed Expert Ranking (ER) framework to rank the candidate expert collaborators based on their likelihood of collaborating in response to a query formulated by the social network of a query initiator and certain required skills to a project/task. We evaluate our proposal using a dataset collected from Github.com, which is one of the most fast-growing, large-scale online OSS community. In addition, we test the models under different data scarcity levels. The experiment shows promising results of recommending expert collaborators who tend to make real collaborations to projects.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 23rd {ACM} {International} {Conference} on {Conference} on {Information} and {Knowledge} {Management}},
	publisher = {ACM},
	author = {Allaho, Mohammad Y. and Lee, Wang-Chien},
	year = {2014},
	keywords = {degree of knowledge, expert ranking, open source software, responsiveness, social relative importance},
	pages = {749--758},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/P2IACMGA/Allaho and Lee - 2014 - Increasing the Responsiveness of Recommended Exper.pdf:application/pdf}
}

@inproceedings{greiler_code_2015,
	address = {Piscataway, NJ, USA},
	series = {{MSR} '15},
	title = {Code {Ownership} and {Software} {Quality}: {A} {Replication} {Study}},
	isbn = {978-0-7695-5594-2},
	shorttitle = {Code {Ownership} and {Software} {Quality}},
	url = {http://dl.acm.org/citation.cfm?id=2820518.2820522},
	abstract = {In a traditional sense, ownership determines rights and duties in regard to an object, for example a property. The owner of source code usually refers to the person that invented the code. However, larger code artifacts, such as files, are usually composed by multiple engineers contributing to the entity over time through a series of changes. Frequently, the person with the highest contribution, e.g. the most number of code changes, is defined as the code owner and takes responsibility for it. Thus, code ownership relates to the knowledge engineers have about code. Lacking responsibility and knowledge about code can reduce code quality. In an earlier study, Bird et al. [1] showed that Windows binaries that lacked clear code ownership were more likely to be defect prone. However recommendations for large artifacts such as binaries are usually not actionable. E.g. changing the concept of binaries and refactoring them to ensure strong ownership would violate system architecture principles. A recent replication study by Foucault et al. [2] on open source software replicate the original results and lead to doubts about the general concept of ownership impacting code quality. In this paper, we replicated and extended the previous two ownership studies [1, 2] and reflect on their findings. Further, we define several new ownership metrics to investigate the dependency between ownership and code quality on file and directory level for 4 major Microsoft products. The results confirm the original findings by Bird et al. [1] that code ownership correlates with code quality. Using new and refined code ownership metrics we were able to classify source files that contained at least one bug with a median precision of 0.74 and a median recall of 0.38. On directory level, we achieve a precision of 0.76 and a recall of 0.60.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 12th {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {IEEE Press},
	author = {Greiler, Michaela and Herzig, Kim and Czerwonka, Jacek},
	year = {2015},
	keywords = {code ownership, empirical software engineering, software quality},
	pages = {2--12},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/XEJFYUQ4/Greiler et al. - 2015 - Code Ownership and Software Quality A Replication.pdf:application/pdf}
}

@inproceedings{zieris_knowledge_2014,
	address = {New York, NY, USA},
	series = {{ESEM} '14},
	title = {On {Knowledge} {Transfer} {Skill} in {Pair} {Programming}},
	isbn = {978-1-4503-2774-9},
	url = {http://doi.acm.org/10.1145/2652524.2652529},
	doi = {10.1145/2652524.2652529},
	abstract = {Context: General knowledge transfer is often considered a valuable effect or side-effect of pair programming, but even more important is its role for the success of the pair programming session itself: The partners often need to explain an idea to carry the process forward. Goal: Understand the mechanisms at work when knowledge is transferred during a pair programming session; provide practical advice for constructive behavior. Method: Qualitative data analysis of recordings of actual industrial pair programming sessions. Results: Some pairs are much more efficient in their knowledge transfer than others. These pairs manage to (1) not attempt to explain multiple things at once, (2) not lose sight of a topic, (3) clarify difficult points in stages. Conclusions: Pair programming requires skill beyond software development skill. To be able to identify knowledge needs and then push such knowledge to or pull it from the partner successfully is one aspect of such skill. We characterize a number of its elements.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 8th {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement}},
	publisher = {ACM},
	author = {Zieris, Franz and Prechelt, Lutz},
	year = {2014},
	keywords = {agile software development, collaboration, pair programming},
	pages = {11:1--11:10},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/EQEBAJXA/Zieris and Prechelt - 2014 - On Knowledge Transfer Skill in Pair Programming.pdf:application/pdf}
}

@inproceedings{ricca_are_2010,
	address = {New York, NY, USA},
	series = {{ESEM} '10},
	title = {Are {Heroes} {Common} in {FLOSS} {Projects}?},
	isbn = {978-1-4503-0039-1},
	url = {http://doi.acm.org/10.1145/1852786.1852856},
	doi = {10.1145/1852786.1852856},
	abstract = {Several projects rely on one or more Heroes who are the only ones who understand and know certain critical parts of a system. Often Heroes are very useful in the economy of a project but, their presence can increase the risk of project failure if they decide to leave the project. For this reason, tools for measuring the amount of spread of knowledge within a team (i.e. the Truck factor) and identifying possible Heroes are welcomed. In this paper, we have implemented a tool to compute the Truck factor and identify Heroes in a project. To assess the applicability and usefulness of the tool we have applied it to 20 randomly selected FLOSS projects. Preliminary results are encouraging: the approach seems to be applicable and useful. We found that Heroes are common in the considered set of FLOSS projects and that the Truck factor is in general low.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2010 {ACM}-{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement}},
	publisher = {ACM},
	author = {Ricca, Filippo and Marchetto, Alessandro},
	year = {2010},
	keywords = {code ownership, Heroes, project management, truck factor},
	pages = {55:1--55:4},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/KI7SNLD7/Ricca and Marchetto - 2010 - Are Heroes Common in FLOSS Projects.pdf:application/pdf}
}

@inproceedings{minto_recommending_2007,
	address = {Washington, DC, USA},
	series = {{MSR} '07},
	title = {Recommending {Emergent} {Teams}},
	isbn = {978-0-7695-2950-9},
	url = {http://dx.doi.org/10.1109/MSR.2007.27},
	doi = {10.1109/MSR.2007.27},
	abstract = {To build successful complex software systems, developers must collaborate with each other to solve issues. To facilitate this collaboration, specialized tools, such as chat and screen sharing, are being integrated into development environments. Currently, these tools require a developer to maintain a list of other developers with whom they may wish to communicate and to determine who within this list has expertise for a specific situation. For large, dynamic projects, like several successful open-source projects, these requirements place an unreasonable burden on the developer. In this paper, we show how the structure of a team emerges from how developers change software artifacts. We introduce the Emergent Expertise Locator (EEL) that uses emergent team information to propose experts to a developer within their development environment as the developer works. We found that EEL produces, on average, results with higher precision and higher recall than an existing heuristic for expertise recommendation.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the {Fourth} {International} {Workshop} on {Mining} {Software} {Repositories}},
	publisher = {IEEE Computer Society},
	author = {Minto, Shawn and Murphy, Gail C.},
	year = {2007},
	pages = {5--},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/H62B3FRF/Minto and Murphy - 2007 - Recommending Emergent Teams.pdf:application/pdf;ACM Full Text PDF:/Users/Felix/Zotero/storage/ZCNW36M8/Minto and Murphy - 2007 - Recommending Emergent Teams.pdf:application/pdf}
}

@inproceedings{bird_dont_2011,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} '11},
	title = {Don'{T} {Touch} {My} {Code}!: {Examining} the {Effects} of {Ownership} on {Software} {Quality}},
	isbn = {978-1-4503-0443-6},
	shorttitle = {Don'{T} {Touch} {My} {Code}!},
	url = {http://doi.acm.org/10.1145/2025113.2025119},
	doi = {10.1145/2025113.2025119},
	abstract = {Ownership is a key aspect of large-scale software development. We examine the relationship between different ownership measures and software failures in two large software projects: Windows Vista and Windows 7. We find that in all cases, measures of ownership such as the number of low-expertise developers, and the proportion of ownership for the top owner have a relationship with both pre-release faults and post-release failures. We also empirically identify reasons that low-expertise developers make changes to components and show that the removal of low-expertise contributions dramatically decreases the performance of contribution based defect prediction. Finally we provide recommendations for source code change policies and utilization of resources such as code inspections based on our results.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 19th {ACM} {SIGSOFT} {Symposium} and the 13th {European} {Conference} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Bird, Christian and Nagappan, Nachiappan and Murphy, Brendan and Gall, Harald and Devanbu, Premkumar},
	year = {2011},
	keywords = {emprical software engineering, expertise, ownership, quality},
	pages = {4--14},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/MDQPFWMD/Bird et al. - 2011 - Don'T Touch My Code! Examining the Effects of Own.pdf:application/pdf}
}

@inproceedings{thompson_recommending_2014,
	address = {New York, NY, USA},
	series = {{RSSE} 2014},
	title = {Recommending a {Starting} {Point} for a {Programming} {Task}: {An} {Initial} {Investigation}},
	isbn = {978-1-4503-2845-6},
	shorttitle = {Recommending a {Starting} {Point} for a {Programming} {Task}},
	url = {http://doi.acm.org/10.1145/2593822.2593824},
	doi = {10.1145/2593822.2593824},
	abstract = {When starting a new task, a software developer must typically find one or more starting points amongst many resources (e.g., source code and other files) forming the software system. In this paper, we consider how we might recommend one resource as an initial starting point, saving the developer the effort of having to search or use other means to find the point. Using data from the open source Eclipse Mylyn project, we investigate whether resources considered and changed for other tasks may be used to recommend a starting point for a current task.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 4th {International} {Workshop} on {Recommendation} {Systems} for {Software} {Engineering}},
	publisher = {ACM},
	author = {Thompson, C. Albert and Murphy, Gail C.},
	year = {2014},
	keywords = {program history, repository mining, task similarity},
	pages = {6--8},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/KJF5EYNB/Thompson and Murphy - 2014 - Recommending a Starting Point for a Programming Ta.pdf:application/pdf}
}

@inproceedings{ye_learning_2014,
	address = {New York, NY, USA},
	series = {{FSE} 2014},
	title = {Learning to {Rank} {Relevant} {Files} for {Bug} {Reports} {Using} {Domain} {Knowledge}},
	isbn = {978-1-4503-3056-5},
	url = {http://doi.acm.org/10.1145/2635868.2635874},
	doi = {10.1145/2635868.2635874},
	abstract = {When a new bug report is received, developers usually need to reproduce the bug and perform code reviews to find the cause, a process that can be tedious and time consuming. A tool for ranking all the source files of a project with respect to how likely they are to contain the cause of the bug would enable developers to narrow down their search and potentially could lead to a substantial increase in productivity. This paper introduces an adaptive ranking approach that leverages domain knowledge through functional decompositions of source code files into methods, API descriptions of library components used in the code, the bug-fixing history, and the code change history. Given a bug report, the ranking score of each source file is computed as a weighted combination of an array of features encoding domain knowledge, where the weights are trained automatically on previously solved bug reports using a learning-to-rank technique. We evaluated our system on six large scale open source Java projects, using the before-fix version of the project for every bug report. The experimental results show that the newly introduced learning-to-rank approach significantly outperforms two recent state-of-the-art methods in recommending relevant files for bug reports. In particular, our method makes correct recommendations within the top 10 ranked source files for over 70\% of the bug reports in the Eclipse Platform and Tomcat projects.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 22Nd {ACM} {SIGSOFT} {International} {Symposium} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Ye, Xin and Bunescu, Razvan and Liu, Chang},
	year = {2014},
	keywords = {bug reports, learning to rank, software maintenance},
	pages = {689--699},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/DHRX4U6F/Ye et al. - 2014 - Learning to Rank Relevant Files for Bug Reports Us.pdf:application/pdf}
}

@inproceedings{schuler_mining_2008,
	address = {New York, NY, USA},
	series = {{MSR} '08},
	title = {Mining {Usage} {Expertise} from {Version} {Archives}},
	isbn = {978-1-60558-024-1},
	url = {http://doi.acm.org/10.1145/1370750.1370779},
	doi = {10.1145/1370750.1370779},
	abstract = {In software development, there is an increasing need to find and connect developers with relevant expertise. Existing expertise recommendation systems are mostly based on variations of the Line 10 Rule: developers who changed a file most often have the most implementation expertise. In this paper, we introduce the concept of usage expertise, which manifests itself whenever developers are using functionality, e.g., by calling API methods. We present preliminary results for the ECLIPSE project that demonstrate that our technique allows to recommend experts for files with no or little history, identify developers with similar expertise, and measure the usage of API methods.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2008 {International} {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Schuler, David and Zimmermann, Thomas},
	year = {2008},
	keywords = {computer-supported cooperative work, expertise recommendation, software repository},
	pages = {121--124},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/UDJW5QYK/Schuler and Zimmermann - 2008 - Mining Usage Expertise from Version Archives.pdf:application/pdf}
}

@inproceedings{mo_geminer:_2015,
	address = {New York, NY, USA},
	series = {Internetware '15},
	title = {{GEMiner}: {Mining} {Social} and {Programming} {Behaviors} to {Identify} {Experts} in {Github}},
	isbn = {978-1-4503-3641-3},
	shorttitle = {{GEMiner}},
	url = {http://doi.acm.org/10.1145/2875913.2875924},
	doi = {10.1145/2875913.2875924},
	abstract = {Hosting over 10 million repositories, GitHub becomes the largest open source community in the world. Besides sharing code, Github is also a social network, in which developers can follow others or keep track of their interested projects. Considering the multi-roles of Github, integrating heterogenous data of each developer to identify experts is a challenging task. In this paper, we propose GEMiner, a novel approach to identify experts for some specific programming languages in Github. Different from previous approaches, GEMiner analyzes the social behaviors and programming behaviors of a developer to determine the expertise of the developer. When modeling social behaviors of developers, to integrate heterogenous social networks in Github, GEMiner implements a Multi-Sources PageRank algorithm. Also, GEMiner analyzes the behaviors of developers when they are programming (e.g., their commit activities and their preferred programming languages) to model programming behaviors of them. Based on our expertise models and our extracted programming languages data, GEMiner can then identify experts for some specific programming languages in Github. We conducted experiments on a real data set, and our results show that GEMiner identifies experts with 60\% accuracy higher than the state-of-the-art algorithms.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 7th {Asia}-{Pacific} {Symposium} on {Internetware}},
	publisher = {ACM},
	author = {Mo, Wenkai and Shen, Beijun and He, Yuming and Zhong, Hao},
	year = {2015},
	keywords = {Experts Identification, Github, Social Network},
	pages = {93--101},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/4Y6XYFI5/Mo et al. - 2015 - GEMiner Mining Social and Programming Behaviors t.pdf:application/pdf}
}

@inproceedings{bacchelli_expectations_2013,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '13},
	title = {Expectations, {Outcomes}, and {Challenges} of {Modern} {Code} {Review}},
	isbn = {978-1-4673-3076-3},
	url = {http://dl.acm.org/citation.cfm?id=2486788.2486882},
	abstract = {Code review is a common software engineering practice employed both in open source and industrial contexts. Review today is less formal and more lightweight than the code inspections performed and studied in the 70s and 80s. We empirically explore the motivations, challenges, and outcomes of tool-based code reviews. We observed, interviewed, and surveyed developers and managers and manually classified hundreds of review comments across diverse teams at Microsoft. Our study reveals that while finding defects remains the main motivation for review, reviews are less about defects than expected and instead provide additional benefits such as knowledge transfer, increased team awareness, and creation of alternative solutions to problems. Moreover, we find that code and change understanding is the key aspect of code reviewing and that developers employ a wide range of mechanisms to meet their understanding needs, most of which are not met by current tools. We provide recommendations for practitioners and researchers.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2013 {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Bacchelli, Alberto and Bird, Christian},
	year = {2013},
	pages = {712--721},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/UC7J3EUB/Bacchelli and Bird - 2013 - Expectations, Outcomes, and Challenges of Modern C.pdf:application/pdf}
}

@inproceedings{bayati_security_2016,
	address = {New York, NY, USA},
	series = {{ICSE} '16},
	title = {Security {Expert} {Recommender} in {Software} {Engineering}},
	isbn = {978-1-4503-4205-6},
	url = {http://doi.acm.org/10.1145/2889160.2892648},
	doi = {10.1145/2889160.2892648},
	abstract = {Software engineering is a complex filed with diverse specialties. By the growth of Internet based applications, information security plays an important role in software development process. Finding expert software engineers who have expertise in information security requires too much effort. Stack Overflow is the largest social Q\&A Website in the field of software engineering. Stack Overflow contains developers' posts and answers in different software engineering areas including information security. Security related posts are asked in conjunction with various technologies, programming languages, tools and frameworks. In this paper, the content and metadata of Stack Overflow is analysed to find experts in diverse software engineering security related concepts using information security ontology.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering} {Companion}},
	publisher = {ACM},
	author = {Bayati, Shahab},
	year = {2016},
	keywords = {expert recommendation, information security, ontology, recommender system, software engineering, stack overflow},
	pages = {719--721},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/QRVD7HS8/Bayati - 2016 - Security Expert Recommender in Software Engineerin.pdf:application/pdf}
}

@inproceedings{fritz_does_2007,
	address = {New York, NY, USA},
	series = {{ESEC}-{FSE} '07},
	title = {Does a {Programmer}'s {Activity} {Indicate} {Knowledge} of {Code}?},
	isbn = {978-1-59593-811-4},
	url = {http://doi.acm.org/10.1145/1287624.1287673},
	doi = {10.1145/1287624.1287673},
	abstract = {The practice of software development can likely be improved if an externalized model of each programmer's knowledge of a particular code base is available. Some tools already assume a useful form of such a model can be created from data collected during development, such as expertise recommenders that use information about who has changed each file to suggest who might answer questions about particular parts of a system. In this paper, we report on an empirical study that investigates whether a programmer's activity can be used to build a model of what a programmer knows about a code base. In this study, nineteen professional Java programmers completed a series of questionnaires about the code on which they were working. These questionnaires were generated automatically and asked about program elements a programmer had worked with frequently and recently and ones that he had not. We found that a degree of interest model based on this frequency and recency of interaction can often indicate the parts of the code base for which the programmer has knowledge. We also determined a number of factors that may be used to improve the model, such as authorship of program elements, the role of elements, and the task being performed.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the the 6th {Joint} {Meeting} of the {European} {Software} {Engineering} {Conference} and the {ACM} {SIGSOFT} {Symposium} on {The} {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Fritz, Thomas and Murphy, Gail C. and Hill, Emily},
	year = {2007},
	keywords = {degree-of-interest, interaction, program structure, structural knowledge},
	pages = {341--350},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/WPDMR3C5/Fritz et al. - 2007 - Does a Programmer's Activity Indicate Knowledge of.pdf:application/pdf}
}

@inproceedings{kim_memories_2006,
	address = {New York, NY, USA},
	series = {{SIGSOFT} '06/{FSE}-14},
	title = {Memories of {Bug} {Fixes}},
	isbn = {978-1-59593-468-0},
	url = {http://doi.acm.org/10.1145/1181775.1181781},
	doi = {10.1145/1181775.1181781},
	abstract = {The change history of a software project contains a rich collection of code changes that record previous development experience. Changes that fix bugs are especially interesting, since they record both the old buggy code and the new fixed code. This paper presents a bug finding algorithm using bug fix memories: a project-specific bug and fix knowledge base developed by analyzing the history of bug fixes. A bug finding tool, BugMem, implements the algorithm. The approach is different from bug finding tools based on theorem proving or static model checking such as Bandera, ESC/Java, FindBugs, JLint, and PMD. Since these tools use pre-defined common bug patterns to find bugs, they do not aim to identify project-specific bugs. Bug fix memories use a learning process, so the bug patterns are project-specific, and project-specific bugs can be detected. The algorithm and tool are assessed by evaluating if real bugs and fixes in project histories can be found in the bug fix memories. Analysis of five open source projects shows that, for these projects, 19.3\%-40.3\% of bugs appear repeatedly in the memories, and 7.9\%-15.5\% of bug and fix pairs are found in memories. The results demonstrate that project-specific bug fix patterns occur frequently enough to be useful as a bug detection technique. Furthermore, for the bug and fix pairs, it is possible to both detect the bug and provide a strong suggestion for the fix. However, there is also a high false positive rate, with 20.8\%-32.5\% of non-bug containing changes also having patterns found in the memories. A comparison of BugMem with a bug finding tool, PMD, shows that the bug sets identified by both tools are mostly exclusive, indicating that BugMem complements other bug finding tools.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 14th {ACM} {SIGSOFT} {International} {Symposium} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Kim, Sunghun and Pan, Kai and Whitehead, Jr., E. E. James},
	year = {2006},
	keywords = {bug, bug finding tool, fault, fix, patterns, prediction},
	pages = {35--45},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/8N7GFL7T/Kim et al. - 2006 - Memories of Bug Fixes.pdf:application/pdf}
}

@inproceedings{costa_tipmerge:_2016,
	address = {New York, NY, USA},
	series = {{FSE} 2016},
	title = {{TIPMerge}: {Recommending} {Experts} for {Integrating} {Changes} {Across} {Branches}},
	isbn = {978-1-4503-4218-6},
	shorttitle = {{TIPMerge}},
	url = {http://doi.acm.org/10.1145/2950290.2950339},
	doi = {10.1145/2950290.2950339},
	abstract = {Parallel development in branches is a common software practice. However, past work has found that integration of changes across branches is not easy, and often leads to failures. Thus far, there has been little work to recommend developers who have the right expertise to perform a branch integration. We propose TIPMerge, a novel tool that recommends developers who are best suited to perform merges, by taking into consideration developers‚Äô past experience in the project, their changes in the branches, and de-pendencies among modified files in the branches. We evaluated TIPMerge on 28 projects, which included up to 15,584 merges with at least two developers, and potentially conflicting changes. On average, 85\% of the top-3 recommendations by TIPMerge correctly included the developer who performed the merge. Best (accuracy) results of recommendations were at 98\%. Our inter-views with developers of two projects reveal that in cases where the TIPMerge recommendation did not match the actual merge developer, the recommended developer had the expertise to per-form the merge, or was involved in a collaborative merge session.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2016 24th {ACM} {SIGSOFT} {International} {Symposium} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Costa, Catarina and Figueiredo, Jair and Murta, Leonardo and Sarma, Anita},
	year = {2016},
	keywords = {Branch Merge, Expertise Recommendation, Version Control},
	pages = {523--534},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/H9GSV9KC/Costa et al. - 2016 - TIPMerge Recommending Experts for Integrating Cha.pdf:application/pdf}
}

@inproceedings{panjer_cooperation_2008,
	address = {New York, NY, USA},
	series = {{CHASE} '08},
	title = {Cooperation and {Coordination} {Concerns} in a {Distributed} {Software} {Development} {Project}},
	isbn = {978-1-60558-039-5},
	url = {http://doi.acm.org/10.1145/1370114.1370134},
	doi = {10.1145/1370114.1370134},
	abstract = {Enabling effective coordination of work in large distributed software projects requires cooperation between participants across multiple teams, sites, and skill sets. To determine how practicing software engineers, in a distributed software development setting, maintain awareness of dependencies and coordinate to resolve dependencies in their work, we conducted a field study that used interviews and informal observation of a distributed software team. In this paper we present key interesting themes that emerged from the qualitative analysis: proximity, modification request authoring patterns, and uncooperative behaviours. We discuss these findings and outline future quantitative research plans to triangulate the methods used by software developers with recorded activities in engineering repositories to increase the generalizability of the research findings.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2008 {International} {Workshop} on {Cooperative} and {Human} {Aspects} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Panjer, Lucas D. and Damian, Daniela and Storey, Margaret-Anne},
	year = {2008},
	keywords = {coordination, dependency management, distributed software development},
	pages = {77--80},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/72CMRS8E/Panjer et al. - 2008 - Cooperation and Coordination Concerns in a Distrib.pdf:application/pdf}
}

@inproceedings{konopka_discovering_2015,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '15},
	title = {Discovering {Code} {Dependencies} by {Harnessing} {Developer}'s {Activity}},
	url = {http://dl.acm.org/citation.cfm?id=2819009.2819174},
	abstract = {Monitoring software developer's interactions in an integrated development environment is sought for revealing new information about developers and developed software. In this paper we present an approach for identifying potential source code dependencies solely from interaction data. We identify three kinds of potential dependencies and additionally assign them to developer's activity as well, to reveal detailed task-related connections in the source code. Interaction data as a source allow us to identify these candidates for dependencies even for dynamically typed programming languages, or across multiple languages in the source code. After first evaluations and positive results we continue with collecting data in professional environment of Web developers, and evaluating our approach.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 37th {International} {Conference} on {Software} {Engineering} - {Volume} 2},
	publisher = {IEEE Press},
	author = {Konopka, Martin and Navrat, Pavol and Bielikova, Maria},
	year = {2015},
	keywords = {dynamic typing, implicit feedback, interaction data, source code dependency, task context},
	pages = {801--802},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/XL7GDDXZ/Konopka et al. - 2015 - Discovering Code Dependencies by Harnessing Develo.pdf:application/pdf}
}

@inproceedings{de_souza_ranking_2014,
	address = {New York, NY, USA},
	series = {{ICPC} 2014},
	title = {Ranking {Crowd} {Knowledge} to {Assist} {Software} {Development}},
	isbn = {978-1-4503-2879-1},
	url = {http://doi.acm.org/10.1145/2597008.2597146},
	doi = {10.1145/2597008.2597146},
	abstract = {StackOverflow.com (SO) is a Question and Answer service oriented to support collaboration among developers in order to help them solving their issues related to software development. In SO, developers post questions related to a programming topic and other members of the site can provide answers to help them. The information available on this type of service is also known as "crowd knowledge" and currently is one important trend in supporting activities related to software development and maintenance.   We present an approach that makes use of "crowd knowledge" available in SO to recommend information that can assist developers in their activities. This strategy recommends a ranked list of pairs of questions/answers from SO based on a query (list of terms). The ranking criteria is based on two main aspects: the textual similarity of the pairs with respect to the query (the developer's problem) and the quality of the pairs. Moreover, we developed a classifier to consider only "how-to" posts. We conducted an experiment considering programming problems on three different topics (Swing, Boost and LINQ) widely used by the software development community to evaluate the proposed recommendation strategy. The results have shown that for 77.14\% of the assessed activities, at least one recommended pair proved to be useful concerning the target programming problem. Moreover, for all activities, at least one recommended pair had a source code snippet considered reproducible or almost reproducible.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 22Nd {International} {Conference} on {Program} {Comprehension}},
	publisher = {ACM},
	author = {de Souza, Lucas B. L. and Campos, Eduardo C. and Maia, Marcelo de A.},
	year = {2014},
	keywords = {crowd knowledge, Q\&A services, recommendation systems},
	pages = {72--82},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/GBACECMI/de Souza et al. - 2014 - Ranking Crowd Knowledge to Assist Software Develop.pdf:application/pdf}
}

@inproceedings{pham_automatically_2015,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} 2015},
	title = {Automatically {Recommending} {Test} {Code} {Examples} to {Inexperienced} {Developers}},
	isbn = {978-1-4503-3675-8},
	url = {http://doi.acm.org/10.1145/2786805.2803202},
	doi = {10.1145/2786805.2803202},
	abstract = {New graduates joining the software engineering workforce sometimes have trouble writing test code. Coming from university, they lack a hands-on approach to testing and have little experience with writing tests in a real-world setting. Software companies resort to costly training camps or mentoring initiatives. Not overcoming this lack of testing skills early on can hinder the newcomer‚Äôs professional progress in becoming a high-quality engineer. Studying open source developers, we found that they rely on a project‚Äôs pre-existing test code to learn how to write tests and adapt test code for their own use. We propose to strategically present useful and contextual test code examples from a project‚Äôs test suite to newcomers in order to facilitate learning and test writing. With an automatic suggestion mechanism for valuable test code, the newcomer is enabled to learn how senior developers write tests and copy it. Having access to suitable tests lowers the barrier for writing new tests.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2015 10th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Pham, Raphael and Stoliar, Yauheni and Schneider, Kurt},
	year = {2015},
	keywords = {Examples, Newcomers, Recommendation, Testing},
	pages = {890--893},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/ZUXJRMYT/Pham et al. - 2015 - Automatically Recommending Test Code Examples to I.pdf:application/pdf}
}

@inproceedings{balachandran_reducing_2013,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '13},
	title = {Reducing {Human} {Effort} and {Improving} {Quality} in {Peer} {Code} {Reviews} {Using} {Automatic} {Static} {Analysis} and {Reviewer} {Recommendation}},
	isbn = {978-1-4673-3076-3},
	url = {http://dl.acm.org/citation.cfm?id=2486788.2486915},
	abstract = {Peer code review is a cost-effective software defect detection technique. Tool assisted code review is a form of peer code review, which can improve both quality and quantity of reviews. However, there is a significant amount of human effort involved even in tool based code reviews. Using static analysis tools, it is possible to reduce the human effort by automating the checks for coding standard violations and common defect patterns. Towards this goal, we propose a tool called Review Bot for the integration of automatic static analysis with the code review process. Review Bot uses output of multiple static analysis tools to publish reviews automatically. Through a user study, we show that integrating static analysis tools with code review process can improve the quality of code review. The developer feedback for a subset of comments from automatic reviews shows that the developers agree to fix 93\% of all the automatically generated comments. There is only 14.71\% of all the accepted comments which need improvements in terms of priority, comment message, etc. Another problem with tool assisted code review is the assignment of appropriate reviewers. Review Bot solves this problem by generating reviewer recommendations based on change history of source code lines. Our experimental results show that the recommendation accuracy is in the range of 60\%-92\%, which is significantly better than a comparable method based on file change history.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2013 {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Balachandran, Vipin},
	year = {2013},
	pages = {931--940},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/6DDYJLPH/Balachandran - 2013 - Reducing Human Effort and Improving Quality in Pee.pdf:application/pdf}
}

@article{conboy_method_2010,
	title = {Method and {Developer} {Characteristics} for {Effective} {Agile} {Method} {Tailoring}: {A} {Study} of {XP} {Expert} {Opinion}},
	volume = {20},
	issn = {1049-331X},
	shorttitle = {Method and {Developer} {Characteristics} for {Effective} {Agile} {Method} {Tailoring}},
	url = {http://doi.acm.org/10.1145/1767751.1767753},
	doi = {10.1145/1767751.1767753},
	abstract = {It has long been acknowledged that software methods should be tailored if they are to achieve optimum effect. However comparatively little research has been carried out to date on this topic in general, and more notably, on agile methods in particular. This dearth of evidence in the case of agile methods is especially significant in that it is reasonable to expect that such methods would particularly lend themselves to tailoring. In this research, we present a framework based on interviews with 20 senior software development researchers and a review of the extant literature. The framework is comprised of two sets of factors‚Äîcharacteristics of the method, and developer practices‚Äîthat can improve method tailoring effectiveness. Drawing on the framework, we then interviewed 16 expert XP practitioners to examine the current state and effectiveness of XP tailoring efforts, and to shed light on issues the framework identified as being important. The article concludes with a set of recommendations for research and practice that would advance our understanding of the method tailoring area.},
	number = {1},
	urldate = {2018-03-20},
	journal = {ACM Trans. Softw. Eng. Methodol.},
	author = {Conboy, Kieran and Fitzgerald, Brian},
	month = jul,
	year = {2010},
	keywords = {agile method, contingency, engineering, expert opinion, Extreme programming, software development, tailoring, XP},
	pages = {2:1--2:30},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/S6FY2KI9/Conboy and Fitzgerald - 2010 - Method and Developer Characteristics for Effective.pdf:application/pdf}
}

@inproceedings{yang_empirical_2017,
	address = {New York, NY, USA},
	series = {Internetware'17},
	title = {An {Empirical} {Study} of {Reviewer} {Recommendation} in {Pull}-based {Development} {Model}},
	isbn = {978-1-4503-5313-7},
	url = {http://doi.acm.org/10.1145/3131704.3131718},
	doi = {10.1145/3131704.3131718},
	abstract = {Code review is an important process to reduce code defects and improve software quality. However, in social coding communities using the pull-based model, everyone can submit code changes, which increases the required code review efforts. Therefore, there is a great need of knowing the process of code review and analyzing the pre-existing reviewer recommendation algorithms. In this paper, we do an empirical study about the PRs and their reviewers in Rails project. Moreover, we reproduce a popular and effective IR-based code reviewer recommendation algorithm and validate it on our dataset which contains 16,049 PRs. We find that the inactive reviewers are very important to code reviewing process, however, the pre-existing method's recommendation result strongly depends on the activeness of reviewers.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 9th {Asia}-{Pacific} {Symposium} on {Internetware}},
	publisher = {ACM},
	author = {Yang, Cheng and Zhang, Xunhui and Zeng, Lingbin and Fan, Qiang and Yin, Gang and Wang, Huaimin},
	year = {2017},
	keywords = {code reviewer recommendation, GitHub, pull request},
	pages = {14:1--14:6},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/V6JYW4IM/Yang et al. - 2017 - An Empirical Study of Reviewer Recommendation in P.pdf:application/pdf}
}

@inproceedings{ying_earec:_2016,
	address = {New York, NY, USA},
	series = {{CSI}-{SE} '16},
	title = {{EARec}: {Leveraging} {Expertise} and {Authority} for {Pull}-request {Reviewer} {Recommendation} in {GitHub}},
	isbn = {978-1-4503-4158-5},
	shorttitle = {{EARec}},
	url = {http://doi.acm.org/10.1145/2897659.2897660},
	doi = {10.1145/2897659.2897660},
	abstract = {Pull-Request (PR) is a primary way of code contribution from developers to improve quality of software projects in GitHub. For a popular GitHub project, tens of PR are submitted daily, while only a small number of developers, i.e core developers, have the grant to judge whether to merge these changes into the main branches or not. Due to the time-consumption of PR review and the diversity of PR aspects, it is becoming a big challenge for core developers to quickly discover the useful PR. Currently, recommending appropriate reviewers (developers) for incoming PR to quickly collect meaningful comments, is treated as an effective and crowdsourced way to help core developers to make decisions and thus accelerate project development. In this paper, we propose a reviewer recommendation approach (EARec) which simultaneously considers developer expertise and authority. Specifically, we first construct a graph of incoming PR and possible reviewers, and then take advantage of text similarity of PR and social relations of reviewers to find the appropriate reviewers. The experimental analysis on MSR Mining Challenge Dataset provides good evaluation for our approach in terms of precision and recall.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 3rd {International} {Workshop} on {CrowdSourcing} in {Software} {Engineering}},
	publisher = {ACM},
	author = {Ying, Haochao and Chen, Liang and Liang, Tingting and Wu, Jian},
	year = {2016},
	keywords = {pull-request, random walk with restart, reviewer recommendation, social network},
	pages = {29--35},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/24I8MIWY/Ying et al. - 2016 - EARec Leveraging Expertise and Authority for Pull.pdf:application/pdf}
}

@inproceedings{yang_who_2016,
	address = {New York, NY, USA},
	series = {{ESEM} '16},
	title = {Who {Should} {Take} {This} {Task}?: {Dynamic} {Decision} {Support} for {Crowd} {Workers}},
	isbn = {978-1-4503-4427-2},
	shorttitle = {Who {Should} {Take} {This} {Task}?},
	url = {http://doi.acm.org/10.1145/2961111.2962594},
	doi = {10.1145/2961111.2962594},
	abstract = {Context: The success of crowdsourced software development (CSD) depends on a large crowd of trustworthy software workers who are registering and submitting for their interested tasks in exchange of financial gains. Preliminary analysis on software worker behaviors reveals an alarming task-quitting rate of 82.9\%. Goal: The objective of this study is to empirically investigate worker decision factors and provide better decision support in order to improve the success and efficiency of CSD. Method: We propose a novel problem formulation, DCW-DS, and an analytics-based decision support methodology to guide workers in acceptance of offered development tasks. DCS-DS is evaluated using more than one year's real-world data from TopCoder, the leading CSD platform. Results: Applying Random Forest based machine learning with dynamic updates, we can predict a worker as being a likely quitter with 99\% average precision and 99\% average recall accuracy. Similarly, we achieved 78\% average precision and 88\% average recall for the worker winner class. For workers just following the top three task recommendations, we have shown that the average quitting rate goes down below 6\%. Conclusions: In total, the proposed method can be used to improve total success rate as well as reduce quitting rate of tasks performed.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 10th {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement}},
	publisher = {ACM},
	author = {Yang, Ye and Karim, Muhammad Rezaul and Saremi, Razieh and Ruhe, Guenther},
	year = {2016},
	keywords = {Crowdsourced software development, dynamic decision making, submission rate, submission score, task-quitting, worker behaviors},
	pages = {8:1--8:10},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/38JSYJTR/Yang et al. - 2016 - Who Should Take This Task Dynamic Decision Suppo.pdf:application/pdf}
}

@inproceedings{mockus_expertise_2002,
	address = {New York, NY, USA},
	series = {{ICSE} '02},
	title = {Expertise {Browser}: {A} {Quantitative} {Approach} to {Identifying} {Expertise}},
	isbn = {978-1-58113-472-8},
	shorttitle = {Expertise {Browser}},
	url = {http://doi.acm.org/10.1145/581339.581401},
	doi = {10.1145/581339.581401},
	abstract = {Finding relevant expertise is a critical need in collaborative software engineering, particularly in geographically distributed developments. We introduce a tool that uses data from change management systems to locate people with desired expertise. It uses a quantification of experience, and presents evidence to validate this quantification as a measure of expertise. The tool enables developers, for example, easily to distinguish someone who has worked only briefly in a particular area of the code from someone who has more extensive experience, and to locate people with broad expertise throughout large parts of the product, such as module or even subsystems. In addition, it allows a user to discover expertise profiles for individuals or organizations. Data from a deployment of the tool in a large software development organization shows that newer, remote sites tend to use the tool for expertise location more frequently. Larger, more established sites used the tool to find expertise profiles for people or organizations. We conclude by describing extensions that provide continuous awareness of ongoing work and an interactive, quantitative resume.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 24th {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Mockus, Audris and Herbsleb, James D.},
	year = {2002},
	pages = {503--512},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/CTUIG9RT/Mockus and Herbsleb - 2002 - Expertise Browser A Quantitative Approach to Iden.pdf:application/pdf}
}

@inproceedings{trainer_bridging_2005,
	address = {New York, NY, USA},
	series = {eclipse '05},
	title = {Bridging the {Gap} {Between} {Technical} and {Social} {Dependencies} with {Ariadne}},
	isbn = {978-1-59593-342-3},
	url = {http://doi.acm.org/10.1145/1117696.1117702},
	doi = {10.1145/1117696.1117702},
	abstract = {One of the reasons why large-scale software development is difficult is the number of dependencies that software engineers need to face; e.g., dependencies among the software components and among the development tasks. These dependencies create a need for communication and coordination that requires continuous effort by software developers. Empirical studies, including our own, suggest that technical dependencies among software components create social dependencies among the software developers implementing these components. Based on this observation, we developed Ariadne, a Java plug-in for Eclipse. Ariadne analyzes a Java project to identify program dependencies and collects authorship information about the project by connecting to a configuration management repository. Through this process, Ariadne can "translate" technical dependencies among software components into social dependencies among software developers. This paper describes the design of Ariadne, how it identifies technical dependencies among software components, how it extracts information from configuration management systems and, finally, how it translates this into social dependencies. Ariadne's purpose is to create a bridge between technical and social dependencies.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2005 {OOPSLA} {Workshop} on {Eclipse} {Technology} {eXchange}},
	publisher = {ACM},
	author = {Trainer, Erik and Quirk, Stephen and de Souza, Cleidson and Redmiles, David},
	year = {2005},
	keywords = {collaborative software development, program dependencies, social dependencies},
	pages = {26--30},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/KM54SFE7/Trainer et al. - 2005 - Bridging the Gap Between Technical and Social Depe.pdf:application/pdf}
}

@inproceedings{pohl_what_2008,
	address = {New York, NY, USA},
	series = {{CHASE} '08},
	title = {What {Dynamic} {Network} {Metrics} {Can} {Tell} {Us} {About} {Developer} {Roles}},
	isbn = {978-1-60558-039-5},
	url = {http://doi.acm.org/10.1145/1370114.1370135},
	doi = {10.1145/1370114.1370135},
	abstract = {Software development is heavily dependent on the participants of the process and their roles within the process. Each developer has his specific skills and interests and hence contributes to the project in a different way. While some programmers work on separate modules, others developers integrate these modules towards the final product. To identify such different groups of people one approach is to work with methods taken from social network analysis. To this end, a social network has to be defined in a suitable way, and appropriate analysis strategies have to be chosen. This paper shows how a network of software developers could be defined based on information in a software repository, and what it can possibly tell about roles of developers (and what not) in the process of the application server Tomcat.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2008 {International} {Workshop} on {Cooperative} and {Human} {Aspects} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Pohl, Mathias and Diehl, Stephan},
	year = {2008},
	keywords = {identifying roles, social network analysis},
	pages = {81--84},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/CHQ25G6B/Pohl and Diehl - 2008 - What Dynamic Network Metrics Can Tell Us About Dev.pdf:application/pdf}
}

@article{pan_transfer_2016,
	title = {Transfer {Learning} for {Semisupervised} {Collaborative} {Recommendation}},
	volume = {6},
	issn = {2160-6455},
	url = {http://doi.acm.org/10.1145/2835497},
	doi = {10.1145/2835497},
	abstract = {Users‚Äô online behaviors such as ratings and examination of items are recognized as one of the most valuable sources of information for learning users‚Äô preferences in order to make personalized recommendations. But most previous works focus on modeling only one type of users‚Äô behaviors such as numerical ratings or browsing records, which are referred to as explicit feedback and implicit feedback, respectively. In this article, we study a Semisupervised Collaborative Recommendation (SSCR) problem with labeled feedback (for explicit feedback) and unlabeled feedback (for implicit feedback), in analogy to the well-known Semisupervised Learning (SSL) setting with labeled instances and unlabeled instances. SSCR is associated with two fundamental challenges, that is, heterogeneity of two types of users‚Äô feedback and uncertainty of the unlabeled feedback. As a response, we design a novel Self-Transfer Learning (sTL) algorithm to iteratively identify and integrate likely positive unlabeled feedback, which is inspired by the general forward/backward process in machine learning. The merit of sTL is its ability to learn users‚Äô preferences from heterogeneous behaviors in a joint and selective manner. We conduct extensive empirical studies of sTL and several very competitive baselines on three large datasets. The experimental results show that our sTL is significantly better than the state-of-the-art methods.},
	number = {2},
	urldate = {2018-03-20},
	journal = {ACM Trans. Interact. Intell. Syst.},
	author = {Pan, Weike and Yang, Qiang and Duan, Yuchao and Ming, Zhong},
	month = jul,
	year = {2016},
	keywords = {Collaborative recommendation, labeled feedback, unlabeled feedback},
	pages = {10:1--10:21},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/CX8VD4BZ/Pan et al. - 2016 - Transfer Learning for Semisupervised Collaborative.pdf:application/pdf}
}

@inproceedings{meneely_socio-technical_2011,
	address = {New York, NY, USA},
	series = {{ICSE} '11},
	title = {Socio-technical {Developer} {Networks}: {Should} {We} {Trust} {Our} {Measurements}?},
	isbn = {978-1-4503-0445-0},
	shorttitle = {Socio-technical {Developer} {Networks}},
	url = {http://doi.acm.org/10.1145/1985793.1985832},
	doi = {10.1145/1985793.1985832},
	abstract = {Software development teams must be properly structured to provide effectiv collaboration to produce quality software. Over the last several years, social network analysis (SNA) has emerged as a popular method for studying the collaboration and organization of people working in large software development teams. Researchers have been modeling networks of developers based on socio-technical connections found in software development artifacts. Using these developer networks, researchers have proposed several SNA metrics that can predict software quality factors and describe the team structure. But do SNA metrics measure what they purport to measure? The objective of this research is to investigate if SNA metrics represent socio-technical relationships by examining if developer networks can be corroborated with developer perceptions. To measure developer perceptions, we developed an online survey that is personalized to each developer of a development team based on that developer's SNA metrics. Developers answered questions about other members of the team, such as identifying their collaborators and the project experts. A total of 124 developers responded to our survey from three popular open source projects: the Linux kernel, the PHP programming language, and the Wireshark network protocol analyzer. Our results indicate that connections in the developer network are statistically associated with the collaborators whom the developers named. Our results substantiate that SNA metrics represent socio-technical relationships in open source development projects, while also clarifying how the developer network can be interpreted by researchers and practitioners.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 33rd {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Meneely, Andrew and Williams, Laurie},
	year = {2011},
	keywords = {developer network, developers, social network analysis},
	pages = {281--290},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/DY2MYBF8/Meneely and Williams - 2011 - Socio-technical Developer Networks Should We Trus.pdf:application/pdf}
}

@inproceedings{mani_mining_2016,
	address = {New York, NY, USA},
	series = {{ISEC} '16},
	title = {Mining {API} {Expertise} {Profiles} with {Partial} {Program} {Analysis}},
	isbn = {978-1-4503-4018-2},
	url = {http://doi.acm.org/10.1145/2856636.2856646},
	doi = {10.1145/2856636.2856646},
	abstract = {A developer's API usage expertise can be estimated by analyzing source code that they have checked-in to a software repository. In prior work we proposed a system for creating a social network of developers centered around the APIs they use in order to recommend people and projects they might be interested in. The implementation of such a system requires analyzing code from repositories of large numbers of projects that use different build systems. Hence, one challenge is to determine the APIs referenced in code in these repositories without relying on the ability to resolve every project's external dependencies. In this paper, we consider a technique called Partial Program Analysis for resolving type bindings in Java source code in the absence of third-party library binaries. Another important design decision concerns the approach of associating such API references with the developers who authored them such as walking entire change history or use blame information. We evaluate these different design options on 4 open-source Java projects and found that both Partial Program Analysis and blame-based approach provide precision greater than 80\%. However, use of blame as opposed to complete program history leads to significant recall loss, in most cases greater than 40\%.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 9th {India} {Software} {Engineering} {Conference}},
	publisher = {ACM},
	author = {Mani, Senthil and Padhye, Rohan and Sinha, Vibha Singhal},
	year = {2016},
	keywords = {API usage expertise, Blame, Change History, Partial Program Analysis},
	pages = {109--118},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/NTDPXQ9E/Mani et al. - 2016 - Mining API Expertise Profiles with Partial Program.pdf:application/pdf}
}

@inproceedings{zou_understanding_2008,
	address = {New York, NY, USA},
	series = {{RSSE} '08},
	title = {Understanding {Interaction} {Differences} {Between} {Newcomer} and {Expert} {Programmers}},
	isbn = {978-1-60558-228-3},
	url = {http://doi.acm.org/10.1145/1454247.1454256},
	doi = {10.1145/1454247.1454256},
	abstract = {Newcomer and expert programmers often interact with development artifacts differently. Ideally, software development tools should support these different styles of work. In this paper, we describe our investigations into the interaction difference between newcomers and experts, regarding two properties that characterize repetition of programmer interaction: temporal locality and interaction coupling recurrence. We describe our approach, research questions and planned methodology.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2008 {International} {Workshop} on {Recommendation} {Systems} for {Software} {Engineering}},
	publisher = {ACM},
	author = {Zou, Lijie and Godfrey, Michael W.},
	year = {2008},
	keywords = {developer behavior, newcomer and expert},
	pages = {26--29},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/D6W84PLI/Zou and Godfrey - 2008 - Understanding Interaction Differences Between Newc.pdf:application/pdf}
}

@inproceedings{mende_replication_2010,
	address = {New York, NY, USA},
	series = {{PROMISE} '10},
	title = {Replication of {Defect} {Prediction} {Studies}: {Problems}, {Pitfalls} and {Recommendations}},
	isbn = {978-1-4503-0404-7},
	shorttitle = {Replication of {Defect} {Prediction} {Studies}},
	url = {http://doi.acm.org/10.1145/1868328.1868336},
	doi = {10.1145/1868328.1868336},
	abstract = {Background: The main goal of the PROMISE repository is to enable reproducible, and thus verifiable or refutable research. Over time, plenty of data sets became available, especially for defect prediction problems. Aims: In this study, we investigate possible problems and pitfalls that occur during replication. This information can be used for future replication studies, and serve as a guideline for researchers reporting novel results. Method: We replicate two recent defect prediction studies comparing different data sets and learning algorithms, and report missing information and problems. Results: Even with access to the original data sets, replicating previous studies may not lead to the exact same results. The choice of evaluation procedures, performance measures and presentation has a large influence on the reproducibility. Additionally, we show that trivial and random models can be used to identify overly optimistic evaluation measures. Conclusions: The best way to conduct easily reproducible studies is to share all associated artifacts, e.g. scripts and programs used. When this is not an option, our results can be used to simplify the replication task for other researchers.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 6th {International} {Conference} on {Predictive} {Models} in {Software} {Engineering}},
	publisher = {ACM},
	author = {Mende, Thilo},
	year = {2010},
	keywords = {defect prediction model, replication},
	pages = {5:1--5:10},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/V7K8JMCD/Mende - 2010 - Replication of Defect Prediction Studies Problems.pdf:application/pdf}
}

@inproceedings{schneider_recommendations_2012,
	address = {Piscataway, NJ, USA},
	series = {{RSSE} '12},
	title = {Recommendations {As} {Learning}: {From} {Discrepancies} to {Software} {Improvement}},
	isbn = {978-1-4673-1759-7},
	shorttitle = {Recommendations {As} {Learning}},
	url = {http://dl.acm.org/citation.cfm?id=2666719.2666726},
	abstract = {Successful software development requires software engineering skills as well as domain and user knowledge. This knowledge is difficult to master. Increasing complexity and fast evolving technologies cause deficits in development and system behavior. They cause discrepancies between expectations and observations. We propose using discrepancies as a trigger for recommendations to developers. Discrepancies in using a software application are combined with discrepancies between development artifacts. To efficiently support software engineers, recommendations must consider knowledge bases of discrepancies and resolution options. They evolve over time along with evolving experience. Hence, recommendations and organizational learning are intertwined.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the {Third} {International} {Workshop} on {Recommendation} {Systems} for {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Schneider, Kurt and G√§rtner, Stefan and Wehrmaker, Tristan and Br√ºgge, Bernd},
	year = {2012},
	keywords = {end-user feedback, heuristics, recommendation},
	pages = {31--32},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/A5ABZVX2/Schneider et al. - 2012 - Recommendations As Learning From Discrepancies to.pdf:application/pdf}
}

@inproceedings{rajan_inferring_2015,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '15},
	title = {Inferring {Behavioral} {Specifications} from {Large}-scale {Repositories} by {Leveraging} {Collective} {Intelligence}},
	url = {http://dl.acm.org/citation.cfm?id=2819009.2819107},
	abstract = {Despite their proven benefits, useful, comprehensible, and efficiently checkable specifications are not widely available. This is primarily because writing useful, non-trivial specifications from scratch is too hard, time consuming, and requires expertise that is not broadly available. Furthermore, the lack of specifications for widely-used libraries and frameworks, caused by the high cost of writing specifications, tends to have a snowball effect. Core libraries lack specifications, which makes specifying applications that use them expensive. To contain the skyrocketing development and maintenance costs of high assurance systems, this self-perpetuating cycle must be broken. The labor cost of specifying programs can be significantly decreased via advances in specification inference and synthesis, and this has been attempted several times, but with limited success. We believe that practical specification inference and synthesis is an idea whose time has come. Fundamental breakthroughs in this area can be achieved by leveraging the collective intelligence available in software artifacts from millions of open source projects. Finegrained access to such data sets has been unprecedented, but is now easily available. We identify research directions and report our preliminary results on advances in specification inference that can be had by using such data sets to infer specifications.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 37th {International} {Conference} on {Software} {Engineering} - {Volume} 2},
	publisher = {IEEE Press},
	author = {Rajan, Hridesh and Nguyen, Tien N. and Leavens, Gary T. and Dyer, Robert},
	year = {2015},
	pages = {579--582},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/BELNPHR9/Rajan et al. - 2015 - Inferring Behavioral Specifications from Large-sca.pdf:application/pdf}
}

@inproceedings{canfora_yoda:_2013,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '13},
	title = {{YODA}: {Young} and {Newcomer} {Developer} {Assistant}},
	isbn = {978-1-4673-3076-3},
	shorttitle = {{YODA}},
	url = {http://dl.acm.org/citation.cfm?id=2486788.2486998},
	abstract = {Mentoring project newcomers is a crucial activity in software projects, and requires to identify people having good communication and teaching skills, other than high expertise on specific technical topics. In this demo we present Yoda (Young and newcOmer Developer Assistant), an Eclipse plugin that identifies and recommends mentors for newcomers joining a software project. Yoda mines developers' communication (e.g., mailing lists) and project versioning systems to identify mentors using an approach inspired to what ArnetMiner does when mining advisor/student relations. Then, it recommends appropriate mentors based on the specific expertise required by the newcomer. The demo shows Yoda in action, illustrating how the tool is able to identify and visualize mentoring relations in a project, and suggest appropriate mentors for a developer who is going to work on certain source code files, or on a given topic.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2013 {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Canfora, Gerardo and Di Penta, Massimiliano and Giannantonio, Stefano and Oliveto, Rocco and Panichella, Sebastiano},
	year = {2013},
	pages = {1331--1334},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/I65YW2ZZ/Canfora et al. - 2013 - YODA Young and Newcomer Developer Assistant.pdf:application/pdf}
}

@inproceedings{zhang_hybrid_2013,
	address = {New York, NY, USA},
	series = {{SAC} '13},
	title = {A {Hybrid} {Bug} {Triage} {Algorithm} for {Developer} {Recommendation}},
	isbn = {978-1-4503-1656-9},
	url = {http://doi.acm.org/10.1145/2480362.2480568},
	doi = {10.1145/2480362.2480568},
	abstract = {With a great number of software applications that have been developed, software maintenance has become an important and challenging task, particularly due to the increasing scale of software projects. Even if developers can create and update bug reports in bug repositories to support software maintenance, a large software project receives a large number of bug reports each day. For reducing the workload of developers, many researchers and software engineers have begun recommending appropriate developers to fix bugs. This process is called bug triage and is a hot research topic for software maintenance. In this paper, we propose a hybrid bug triage algorithm, combining a probability model and an experience model to rank all candidate developers for fixing a new bug. For this study, we adopted the smoothed Unigram Model (UM) instead of the traditional Vector Space Model (VSM) to search similar bug reports. In the probability model, we used a social network to analyze the probability of fixing a new bug for a candidate developer. We first proposed to add a new feature (the number of re-opened bugs) in order to get the fixing probability. In the experience model, we considered the number of fixed bugs and fixing cost for each candidate developer as the estimate factor. In addition, we introduced a new concept, activity factor, to better model developers' experience. We performed the experiments on two large-scale, open source projects. The results show that our method can effectively recommend the best developer for fixing bugs.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 28th {Annual} {ACM} {Symposium} on {Applied} {Computing}},
	publisher = {ACM},
	author = {Zhang, Tao and Lee, Byungjeong},
	year = {2013},
	keywords = {bug triage, experience model, probability model, smoothed unigram model, social network},
	pages = {1088--1094},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/PX3X795T/Zhang and Lee - 2013 - A Hybrid Bug Triage Algorithm for Developer Recomm.pdf:application/pdf}
}

@inproceedings{ford_tech-talk_2017,
	address = {Piscataway, NJ, USA},
	series = {{CHASE} '17},
	title = {The {Tech}-talk {Balance}: {What} {Technical} {Interviewers} {Expect} from {Technical} {Candidates}},
	isbn = {978-1-5386-4039-5},
	shorttitle = {The {Tech}-talk {Balance}},
	url = {https://doi.org/10.1109/CHASE.2017.8},
	doi = {10.1109/CHASE.2017.8},
	abstract = {Software engineer job candidates are not succeeding at technical interviews. Although candidates are able to answer technical questions, there is a mismatch of what candidates think interviewers assess versus what criteria is used in practice. This mismatch in expectations can cost candidates a job opportunity. To determine what criteria interviewers value, we conducted mock technical interviews with software engineer candidates at a university and collected evaluations from interviewers. We analyzed 70 interview evaluations from 9 software companies. Using a grounded theory approach, we compared interviewer interpretations of criteria including: performing a problem solving walkthrough, applying previous experience to problem solving, and the ability to engaging in conversation beyond writing code. From these findings, we provide implications on what candidates can expect to be evaluated on during technical interviews across companies, which can sometimes vary significantly.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 10th {International} {Workshop} on {Cooperative} and {Human} {Aspects} of {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Ford, Denae and Barik, Titus and Rand-Pickett, Leslie and Parnin, Chris},
	year = {2017},
	keywords = {career, interpersonal skills, software engineer, technical interview},
	pages = {43--48},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/BK3HCYZS/Ford et al. - 2017 - The Tech-talk Balance What Technical Interviewers.pdf:application/pdf}
}

@inproceedings{xie_dretom:_2012,
	address = {New York, NY, USA},
	series = {{PROMISE} '12},
	title = {{DRETOM}: {Developer} {Recommendation} {Based} on {Topic} {Models} for {Bug} {Resolution}},
	isbn = {978-1-4503-1241-7},
	shorttitle = {{DRETOM}},
	url = {http://doi.acm.org/10.1145/2365324.2365329},
	doi = {10.1145/2365324.2365329},
	abstract = {Background: In most cases, bug resolution is a collaborative activity among developers in software development where each developer contributes his or her ideas on how to resolve the bug. Although only one developer is recorded as the actual fixer for the bug, the contribution of the developers who participated in the collaboration cannot be neglected. Aims: This paper proposes a new approach, called DRETOM (Developer REcommendation based on TOpic Models), to recommending developers for bug resolution in collaborative behavior. Method: The proposed approach models developers' interest in and expertise on bug resolving activities based on topic models that are built from their historical bug resolving records. Given a new bug report, DRETOM recommends a ranked list of developers who are potential to participate in and contribute to resolving the new bug according to these developers' interest in and expertise on resolving it. Results: Experimental results on Eclipse JDT and Mozilla Firefox projects show that DRETOM can achieve high recall up to 82\% and 50\% with top 5 and top 7 recommendations respectively. Conclusion: Developers' interest in bug resolving activities should be taken into consideration. On condition that the parameter Œ∏ of DRETOM is set properly with trials, the proposed approach is practically useful in terms of recall.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 8th {International} {Conference} on {Predictive} {Models} in {Software} {Engineering}},
	publisher = {ACM},
	author = {Xie, Xihao and Zhang, Wen and Yang, Ye and Wang, Qing},
	year = {2012},
	keywords = {developer recommendation, latent dirichlet allocation, open bug repository, topic models},
	pages = {19--28},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/H65UN9W5/Xie et al. - 2012 - DRETOM Developer Recommendation Based on Topic Mo.pdf:application/pdf}
}

@inproceedings{kintab_recommending_2014,
	address = {Riverton, NJ, USA},
	series = {{CASCON} '14},
	title = {Recommending {Software} {Experts} {Using} {Code} {Similarity} and {Social} {Heuristics}},
	url = {http://dl.acm.org/citation.cfm?id=2735522.2735526},
	abstract = {Successful collaboration among developers is crucial to the completion of software projects in a Distributed Software System Development (DSSD) environment. We have developed an Expert Recommender System Framework (ERSF) that assists a developer (called the "Active Developer") to find other developers who can help them to fix code with which they are having difficulty. The ERSF first looks for other developers with similar technical expertise, as measured by their prior work on code fragments that are similar to (clones of) the code that the Active Developer is working on (the "code at hand"). As well, it analyzes the other developers' social relationships with the Active Developer (available from the DSSD environment) and their social activities within the ERSF (information which helps to maintain developer profiles used in this analysis). This information is then combined to provide a ranked list of potential helpers based on both technical and social measures. A proof of concept experiment shows that the ERSF can recommend experts with good to excellent accuracy, when compared with human rankings of appropriate experts in the same scenarios},
	urldate = {2018-03-20},
	booktitle = {Proceedings of 24th {Annual} {International} {Conference} on {Computer} {Science} and {Software} {Engineering}},
	publisher = {IBM Corp.},
	author = {Kintab, Ghadeer A. and Roy, Chanchal K. and McCalla, Gordon I.},
	year = {2014},
	pages = {4--18},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/DHHGMXL2/Kintab et al. - 2014 - Recommending Software Experts Using Code Similarit.pdf:application/pdf}
}

@article{walz_inside_1993,
	title = {Inside a {Software} {Design} {Team}: {Knowledge} {Acquisition}, {Sharing}, and {Integration}},
	volume = {36},
	issn = {0001-0782},
	shorttitle = {Inside a {Software} {Design} {Team}},
	url = {http://doi.acm.org/10.1145/163430.163447},
	doi = {10.1145/163430.163447},
	number = {10},
	urldate = {2018-03-20},
	journal = {Commun. ACM},
	author = {Walz, Diane B. and Elam, Joyce J. and Curtis, Bill},
	month = oct,
	year = {1993},
	keywords = {case study, empirical studies of software development, requirements determination, software design teams, software management},
	pages = {63--77},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/GSDTVZ9I/Walz et al. - 1993 - Inside a Software Design Team Knowledge Acquisiti.pdf:application/pdf}
}

@inproceedings{maalej_assisting_2010,
	address = {New York, NY, USA},
	series = {{RSSE} '10},
	title = {Assisting {Engineers} in {Switching} {Artifacts} by {Using} {Task} {Semantic} and {Interaction} {History}},
	isbn = {978-1-60558-974-9},
	url = {http://doi.acm.org/10.1145/1808920.1808935},
	doi = {10.1145/1808920.1808935},
	abstract = {Recent empirical studies show that software engineers use 5 tools and 14 artifacts on average for a single task. As development work is frequently interrupted and several simultaneous tasks are performed in parallel, engineers need to switch many times between these tools and artifacts. A lot of time gets wasted in repeatedly locating, reopening or selecting the right artifacts needed next. To address this problem we introduce Switch!, a context-aware artifact recommendation and switching tool. Switch! assists engineers in switching artifacts based on the type of the development task and the interaction history.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2Nd {International} {Workshop} on {Recommendation} {Systems} for {Software} {Engineering}},
	publisher = {ACM},
	author = {Maalej, Walid and Sahm, Alexander},
	year = {2010},
	pages = {59--63},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/D6TZYT8U/Maalej and Sahm - 2010 - Assisting Engineers in Switching Artifacts by Usin.pdf:application/pdf}
}

@inproceedings{treude_how_2011,
	address = {New York, NY, USA},
	series = {{ICSE} '11},
	title = {How {Do} {Programmers} {Ask} and {Answer} {Questions} on the {Web}? ({NIER} {Track})},
	isbn = {978-1-4503-0445-0},
	shorttitle = {How {Do} {Programmers} {Ask} and {Answer} {Questions} on the {Web}?},
	url = {http://doi.acm.org/10.1145/1985793.1985907},
	doi = {10.1145/1985793.1985907},
	abstract = {Question and Answer (Q\&A) websites, such as Stack Overflow, use social media to facilitate knowledge exchange between programmers and fill archives with millions of entries that contribute to the body of knowledge in software development. Understanding the role of Q\&A websites in the documentation landscape will enable us to make recommendations on how individuals and companies can leverage this knowledge effectively. In this paper, we analyze data from Stack Overflow to categorize the kinds of questions that are asked, and to explore which questions are answered well and which ones remain unanswered. Our preliminary findings indicate that Q\&A websites are particularly effective at code reviews and conceptual questions. We pose research questions and suggest future work to explore the motivations of programmers that contribute to Q\&A websites, and to understand the implications of turning Q\&A exchanges into technical mini-blogs through the editing of questions and answers.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 33rd {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Treude, Christoph and Barzilay, Ohad and Storey, Margaret-Anne},
	year = {2011},
	keywords = {q\&a, questions, social media, stack overflow},
	pages = {804--807},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/S8UD826R/Treude et al. - 2011 - How Do Programmers Ask and Answer Questions on the.pdf:application/pdf}
}

@inproceedings{servant_whosefault:_2012,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '12},
	title = {{WhoseFault}: {Automatic} {Developer}-to-fault {Assignment} {Through} {Fault} {Localization}},
	isbn = {978-1-4673-1067-3},
	shorttitle = {{WhoseFault}},
	url = {http://dl.acm.org/citation.cfm?id=2337223.2337228},
	abstract = {This paper describes a new technique, which automatically selects the most appropriate developers for fixing the fault represented by a failing test case, and provides a diagnosis of where to look for the fault. This technique works by incorporating three key components: (1) fault localization to inform locations whose execution correlate with failure, (2) history mining to inform which developers edited each line of code and when, and (3) expertise assignment to map locations to developers. To our knowledge, the technique is the first to assign developers to execution failures, without the need for textual bug reports. We implement this technique in our tool, WhoseFault, and describe an experiment where we utilize a large, open-source project to determine the frequency in which our tool suggests an assignment to the actual developer who fixed the fault. Our results show that 81\% of the time, WhoseFault produced the same developer that actually fixed the fault within the top three suggestions. We also show that our technique improved by a difference between 4\% and 40\% the results of a baseline technique. Finally, we explore the influence of each of the three components of our technique over its results, and compare our expertise algorithm against an existing expertise assessment technique and find that our algorithm provides greater accuracy, by up to 37\%.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 34th {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Servant, Francisco and Jones, James A.},
	year = {2012},
	pages = {36--46},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/S8HT3CQ6/Servant and Jones - 2012 - WhoseFault Automatic Developer-to-fault Assignmen.pdf:application/pdf}
}

@inproceedings{guo_learning_2012,
	address = {New York, NY, USA},
	series = {{CIKM} '12},
	title = {Learning to {Recommend} with {Social} {Relation} {Ensemble}},
	isbn = {978-1-4503-1156-4},
	url = {http://doi.acm.org/10.1145/2396761.2398701},
	doi = {10.1145/2396761.2398701},
	abstract = {Recommender systems with social networks (RSSN) have been well studied in recent works. However, these methods ignore the relationships among items, which may affect the quality of recommendations. Motivated by the observation that related items often have similar ratings, we propose a framework integrating items' relations, users' social graph and user-item rating matrix for recommendation. Experimental results show that our approach performs better than the state-of-art algorithm and the method with only users' social graph ensemble in terms of MAP and RMSE.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 21st {ACM} {International} {Conference} on {Information} and {Knowledge} {Management}},
	publisher = {ACM},
	author = {Guo, Lei and Ma, Jun and Chen, Zhumin and Jiang, Haoran},
	year = {2012},
	keywords = {item relation, matrix factorization, recommender systems, social network, social recommendation},
	pages = {2599--2602},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/ZXD5DIP9/Guo et al. - 2012 - Learning to Recommend with Social Relation Ensembl.pdf:application/pdf}
}

@inproceedings{proksch_evaluating_2016,
	address = {New York, NY, USA},
	series = {{ASE} 2016},
	title = {Evaluating the {Evaluations} of {Code} {Recommender} {Systems}: {A} {Reality} {Check}},
	isbn = {978-1-4503-3845-5},
	shorttitle = {Evaluating the {Evaluations} of {Code} {Recommender} {Systems}},
	url = {http://doi.acm.org/10.1145/2970276.2970330},
	doi = {10.1145/2970276.2970330},
	abstract = {While researchers develop many new exciting code recommender systems, such as method-call completion, code-snippet completion, or code search, an accurate evaluation of such systems is always a challenge. We analyzed the current literature and found that most of the current evaluations rely on artificial queries extracted from released code, which begs the question: Do such evaluations reflect real-life usages? To answer this question, we capture 6,189 fine-grained development histories from real IDE interactions. We use them as a ground truth and extract 7,157 real queries for a specific method-call recommender system. We compare the results of such real queries with different artificial evaluation strategies and check several assumptions that are repeatedly used in research, but never empirically evaluated. We find that an evolving context that is often observed in practice has a major effect on the prediction quality of recommender systems, but is not commonly reflected in artificial evaluations.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 31st {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {ACM},
	author = {Proksch, Sebastian and Amann, Sven and Nadi, Sarah and Mezini, Mira},
	year = {2016},
	keywords = {Artificial Evaluation, Empirical Study, IDE Interaction Data},
	pages = {111--121},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/3DAXPFCV/Proksch et al. - 2016 - Evaluating the Evaluations of Code Recommender Sys.pdf:application/pdf}
}

@inproceedings{henninger_developing_1995,
	address = {New York, NY, USA},
	series = {{SSR} '95},
	title = {Developing {Domain} {Knowledge} {Through} the {Reuse} of {Project} {Experiences}},
	isbn = {978-0-89791-739-1},
	url = {http://doi.acm.org/10.1145/211782.211844},
	doi = {10.1145/211782.211844},
	abstract = {Software development is no longer a homogenous field. Software is being developed for an increasingly diverse set of applications and user populations, each with different characteristics and development constraints. As a consequence, researchers and practitioners have begun to realize the importance of identifying and understanding the characteristics and special development needs of application domains. This paper presents a method for developing and refining knowledge about application domains by creating a repository of project experiences. Subsequent projects can then benefit from these experiences by locating similar projects and reusing the knowledge accumulated in the repository. We develop a framework for a system to capture relationships between development projects and resources for developing software, including process models, methods, technologies, and tools. We then show how this information can be reused to improve the productivity and quality of software development efforts.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 1995 {Symposium} on {Software} {Reusability}},
	publisher = {ACM},
	author = {Henninger, Scott},
	year = {1995},
	pages = {186--195},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/6D69X3AD/Henninger - 1995 - Developing Domain Knowledge Through the Reuse of P.pdf:application/pdf}
}

@inproceedings{yoo_clustering_2009,
	address = {New York, NY, USA},
	series = {{ISSTA} '09},
	title = {Clustering {Test} {Cases} to {Achieve} {Effective} and {Scalable} {Prioritisation} {Incorporating} {Expert} {Knowledge}},
	isbn = {978-1-60558-338-9},
	url = {http://doi.acm.org/10.1145/1572272.1572296},
	doi = {10.1145/1572272.1572296},
	abstract = {Pair-wise comparison has been successfully utilised in order to prioritise test cases by exploiting the rich, valuable and unique knowledge of the tester. However, the prohibitively large cost of the pair-wise comparison method prevents it from being applied to large test suites. In this paper, we introduce a cluster-based test case prioritisation technique. By clustering test cases, based on their dynamic runtime behaviour, we can reduce the required number of pair-wise comparisons significantly. The approach is evaluated on seven test suites ranging in size from 154 to 1,061 test cases. We present an empirical study that shows that the resulting prioritisation is more effective than existing coverage-based prioritisation techniques in terms of rate of fault detection. Perhaps surprisingly, the paper also demonstrates that clustering (even without human input) can outperform unclustered coverage-based technologies, and discusses an automated process that can be used to determine whether the application of the proposed approach would yield improvement.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the {Eighteenth} {International} {Symposium} on {Software} {Testing} and {Analysis}},
	publisher = {ACM},
	author = {Yoo, Shin and Harman, Mark and Tonella, Paolo and Susi, Angelo},
	year = {2009},
	keywords = {ahp, clustering, test case prioritisation},
	pages = {201--212},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/TZPVLXSJ/Yoo et al. - 2009 - Clustering Test Cases to Achieve Effective and Sca.pdf:application/pdf}
}

@inproceedings{sedlmeyer_knowledge-based_1983,
	address = {New York, NY, USA},
	series = {{SIGSOFT} '83},
	title = {Knowledge-based {Fault} {Localization} in {Debugging} ({Preliminary} {Draft})},
	isbn = {978-0-89791-111-5},
	url = {http://doi.acm.org/10.1145/800007.808004},
	doi = {10.1145/800007.808004},
	abstract = {Fault localization in program debugging is the process of identifying program statements which cause anomalous behavior. We have developed a prototype, knowledge-based model of the fault localization process. Novel features of the model include multiple localization tactics and a recognition-based mechanism for program abstraction. An explicit division of knowledge from the applications, programming and language domains facilitate model tuning within as well as across applications domains. We describe model structure and performance for a class of faults associated with master file update programs. We foresee applications of the model as an initial cognitive theory of expertise in fault localization and as a partially automated debugging tool.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the {ACM} {SIGSOFT}/{SIGPLAN} {Software} {Engineering} {Symposium} on {High}-level {Debugging}},
	publisher = {ACM},
	author = {Sedlmeyer, Robert L. and Thompson, William B. and Johnson, Paul E.},
	year = {1983},
	pages = {25--31}
}

@inproceedings{miranda_recommender_2012,
	address = {New York, NY, USA},
	series = {{ESEM} '12},
	title = {Recommender {Systems} for {Manual} {Testing}: {Deciding} {How} to {Assign} {Tests} in a {Test} {Team}},
	isbn = {978-1-4503-1056-7},
	shorttitle = {Recommender {Systems} for {Manual} {Testing}},
	url = {http://doi.acm.org/10.1145/2372251.2372289},
	doi = {10.1145/2372251.2372289},
	abstract = {BACKGROUND: Software testing can be an arduous and expensive activity. A typical activity to maximise testing productivity is to allocate test cases according to the testers' profile. However, optimising the allocation of manual test cases is not a trivial task: in big companies, test managers are responsible for allocating hundreds of test cases among several testers. OBJECTIVE: In this paper we propose and evaluate 2 assignment algorithms for test case allocation and 3 tester profiles based on recommender systems. Each assignment algorithm can be combined with 3 tester profiles, which results in six possible allocation systems. METHOD: We run a controlled experiment that uses 100 test suites, each one with at least 50 test cases, from a real industrial setting in order to compare our allocation systems to the manager's allocation in terms of precision, recall and unassignment (percentage of test cases the algorithm could not allocate). RESULTS: In our experiment, the statistical analysis shows that one of the systems outperforms the others with respect to the precision and recall metrics. For unassignment, three of our six allocation systems achieved zero (best value) for the unassignment rate. CONCLUSION: The results of our experiment suggest that, in similar environments, test managers can use our allocation systems to reduce the amount of time spent in the test case allocation task. In the real industrial setting in which our work was developed, managers spend from 16 to 30 working days a year on test case allocation. Our algorithms can help them do it faster and better.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the {ACM}-{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement}},
	publisher = {ACM},
	author = {Miranda, Breno and Aranha, Eduardo Henrique da Silva and Iyoda, Juliano Manabu},
	year = {2012},
	keywords = {manual testing, recommender systems, test allocation},
	pages = {201--210},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/DALD8XLH/Miranda et al. - 2012 - Recommender Systems for Manual Testing Deciding H.pdf:application/pdf}
}

@inproceedings{begel_codebook:_2010,
	address = {New York, NY, USA},
	series = {{ICSE} '10},
	title = {Codebook: {Discovering} and {Exploiting} {Relationships} in {Software} {Repositories}},
	isbn = {978-1-60558-719-6},
	shorttitle = {Codebook},
	url = {http://doi.acm.org/10.1145/1806799.1806821},
	doi = {10.1145/1806799.1806821},
	abstract = {Loading...},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 32Nd {ACM}/{IEEE} {International} {Conference} on {Software} {Engineering} - {Volume} 1},
	publisher = {ACM},
	author = {Begel, Andrew and Khoo, Yit Phang and Zimmermann, Thomas},
	year = {2010},
	keywords = {inter-team coordination, knowledge management, mining software repositories, regular expression, regular language reachability, social networking},
	pages = {125--134},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/9ZV28TDT/Begel et al. - 2010 - Codebook Discovering and Exploiting Relationships.pdf:application/pdf}
}

@inproceedings{ducasse_review_1988,
	address = {Los Alamitos, CA, USA},
	series = {{ICSE} '88},
	title = {A {Review} of {Automated} {Debugging} {Systems}: {Knowledge}, {Strategies} and {Techniques}},
	isbn = {978-0-89791-258-7},
	shorttitle = {A {Review} of {Automated} {Debugging} {Systems}},
	url = {http://dl.acm.org/citation.cfm?id=55823.55841},
	abstract = {Our review is based on descriptions of 18 existing automated systems on program debugging and of a dozen cognitive studies on debugging. We propose a classification of debugging knowledge, and a description of the corresponding knowledge representation in the systems. Then we propose a classification of global debugging strategies used in the systems, and a description of the corresponding techniques. We assess the identified strategies from a real world program development point of view.
The knowledge types we have identified are 1) knowledge of the intended program, 2) knowledge of the actual program, 3) understanding of the programming language, 4) general programming expertise, 5) knowledge of the application domain, 6) knowledge of bugs, 7) knowledge on debugging methods.
The strategies we have identified are 1) filtering, 2) checking computational equivalence of intended program and actual one, 3) checking the well-formedness of actual program and 4) recognizing stereotyped errors.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 10th {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Computer Society Press},
	author = {Ducass√©, M. and Emde, A.-M.},
	year = {1988},
	pages = {162--171},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/RYVJ8H9W/Ducass√© and Emde - 1988 - A Review of Automated Debugging Systems Knowledge.pdf:application/pdf}
}

@inproceedings{shao_recommending_2017,
	address = {New York, NY, USA},
	series = {{ChineseCSCW} '17},
	title = {Recommending {Answerers} for {Stack} {Overflow} with {LDA} {Model}},
	isbn = {978-1-4503-5352-6},
	url = {http://doi.acm.org/10.1145/3127404.3127426},
	doi = {10.1145/3127404.3127426},
	abstract = {Stack Overflow is the largest Community-based Question Answering (CQA) site for software developers. Its popularity is mainly attributed to the timely answers provided by a great number of developers. When having problems in learning and using new technologies, developers resort to Stack Overflow for help. However, it is difficult to recommend questions to the potential answerers due to the huge numbers of questions. In order to improve the accuracy of question recommending, we need to find out the members who are interested in the fields related to the questions and match the ability of developers with the difficulty of questions. To do so, we need to pay close attention to the behavior of developers. This paper presents a model with two prediction approaches, namely, the traditional feature-based approach and LDA (Latent Dirichlet Allocation) based approach. When a new question arrives, this model will use LDA method to label the question and indicate the proper category to which the question belongs according to latent semantic feature and content feature. Then, with the traditional features of the question and the asker information, the model will recommend the appropriate developers to answer this new question.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 12th {Chinese} {Conference} on {Computer} {Supported} {Cooperative} {Work} and {Social} {Computing}},
	publisher = {ACM},
	author = {Shao, Bin and Yan, Jiafei},
	year = {2017},
	keywords = {classifier, LDA, recommender system, Stack Overflow},
	pages = {80--86},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/RQ6GHG2W/Shao and Yan - 2017 - Recommending Answerers for Stack Overflow with LDA.pdf:application/pdf}
}

@inproceedings{riddell_public_2015,
	address = {New York, NY, USA},
	series = {{OpenSym} '15},
	title = {Public {Domain} {Rank}: {Identifying} {Notable} {Individuals} with the {Wisdom} of the {Crowd}},
	isbn = {978-1-4503-3666-6},
	shorttitle = {Public {Domain} {Rank}},
	url = {http://doi.acm.org/10.1145/2788993.2789850},
	doi = {10.1145/2788993.2789850},
	abstract = {Identifying literary, scientific, and technical works of enduring interest is challenging. Few are able to name significant works across more than a handful of domains or languages. This paper introduces an automatic method for identifying authors of notable works throughout history. Notability is defined using the record of which works volunteers have made available in public domain digital editions. A significant benefit of this bottom-up approach is that it also provides a novel and reproducible index of notability for all individuals with Wikipedia pages. This method promises to supplement the work of cultural organizations and institutions seeking to publicize the availability of notable works and prioritize works for preservation and digitization.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 11th {International} {Symposium} on {Open} {Collaboration}},
	publisher = {ACM},
	author = {Riddell, Allen B.},
	year = {2015},
	keywords = {bibliometrics, information filtering, project gutenberg, public domain, Wikipedia},
	pages = {10:1--10:9},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/PS4G33EA/Riddell - 2015 - Public Domain Rank Identifying Notable Individual.pdf:application/pdf}
}

@inproceedings{da_silva_preliminary_2016,
	address = {New York, NY, USA},
	series = {{ESEM} '16},
	title = {Preliminary {Findings} {About} the {Nature} of {Work} in {Software} {Engineering}: {An} {Exploratory} {Survey}},
	isbn = {978-1-4503-4427-2},
	shorttitle = {Preliminary {Findings} {About} the {Nature} of {Work} in {Software} {Engineering}},
	url = {http://doi.acm.org/10.1145/2961111.2962625},
	doi = {10.1145/2961111.2962625},
	abstract = {Context: Work Design refers to the different ways in which a given work or task can be designed and performed. The study of work design is important because every decision related to how the work is performed can affect the outcomes of individuals and the effectiveness of teamwork. Goal: To investigate work design characteristics of software engineering work and identify areas for future research. Method: We performed a survey with professional software engineers working in different commercial software companies in Brazil. We sent invitations to just over 150 professionals and received 77 valid answers from participants working in 35 distinct software companies. We measured 21 work design constructs, as well as job burnout, role conflict, role ambiguity, and two constructs related to job rotation. Results: Comparisons of our sample with other sample consisting of a diversity of professions showed that software engineering work has distinct characteristics, but some results require further investigation. Conclusion: We identified relevant characteristics of software engineering work and areas for further research. In particular, longitudinal studies are needed to address the temporal variations impossible to identify in cross sectional studies.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 10th {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement}},
	publisher = {ACM},
	author = {da Silva, Fabio Q. B. and Fran√ßa, C√©sar and de Magalh√£es, Cleyton V. C. and Santos, Ronnie E. S.},
	year = {2016},
	keywords = {job burnout, job characteristics, job rotation, software engineering, survey research, work design},
	pages = {10:1--10:6},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/7PIUQFDI/da Silva et al. - 2016 - Preliminary Findings About the Nature of Work in S.pdf:application/pdf}
}

@inproceedings{makihara_pockets:_2015,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} 2015},
	title = {Pockets: {A} {Tool} to {Support} {Exploratory} {Programming} for {Novices} and {Educators}},
	isbn = {978-1-4503-3675-8},
	shorttitle = {Pockets},
	url = {http://doi.acm.org/10.1145/2786805.2807564},
	doi = {10.1145/2786805.2807564},
	abstract = {Exploratory programming is one of the programming techniques, and it is considered to be an effective way to improve programming skills for novices. However, there is no existing system or programming environment educating exploratory programming for novices. Therefore, we have developed a tool, named as Pockets, to support novice's exploratory programming. Through Pockets, educators are able to identify where and when novices experience difficulties during exploratory programming. In addition, it is possible to assist educators' mentoring by referring collected logs through the proposed system. We have also conducted a case study and evaluated the usefulness of the tool. As a result, Pockets makes novices' exploratory programming more efficient, and also allows more accurate advice by educators.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2015 10th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Makihara, Erina},
	year = {2015},
	keywords = {coding process visualization, exploratory programming, programming education},
	pages = {1066--1068},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/CP96H32T/Makihara - 2015 - Pockets A Tool to Support Exploratory Programming.pdf:application/pdf}
}

@inproceedings{borg_is_2015,
	address = {Piscataway, NJ, USA},
	series = {{ICSE} '15},
	title = {Is {Carmen} {Better} {Than} {George}?: {Testing} the {Exploratory} {Tester} {Using} {HCI} {Techniques}},
	shorttitle = {Is {Carmen} {Better} {Than} {George}?},
	url = {http://dl.acm.org/citation.cfm?id=2819009.2819181},
	abstract = {Exploratory software testing is an activity which can be carried out by both untrained and formally trained testers. In this paper, we propose using Human Computer Interaction (HCI) techniques to carry out a study of exploratory testing strategies used by the two groups of testers. This data will be used to make recommendations to companies with regards to the mix of skills and training required for testing teams.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 37th {International} {Conference} on {Software} {Engineering} - {Volume} 2},
	publisher = {IEEE Press},
	author = {Borg, Andrea and Porter, Chris and Micallef, Mark},
	year = {2015},
	pages = {815--816},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/W525YGXC/Borg et al. - 2015 - Is Carmen Better Than George Testing the Explora.pdf:application/pdf}
}

@inproceedings{he_knowledge_2004,
	address = {New York, NY, USA},
	series = {{SIGMIS} {CPR} '04},
	title = {Knowledge {Impacts} of {User} {Participation}: {A} {Cognitive} {Perspective}},
	isbn = {978-1-58113-847-4},
	shorttitle = {Knowledge {Impacts} of {User} {Participation}},
	url = {http://doi.acm.org/10.1145/982372.982374},
	doi = {10.1145/982372.982374},
	abstract = {Although user participation has been studied over four decades, there are still many questions unanswered. This research identifies two gaps in this field: a lack of understanding of the underlying cognitive mechanisms that intervene with the information systems development (ISD) process, and a lack of understanding of knowledge structures between user participants and system developers that may shape the effectiveness of team processes. To fill up the two gaps, I propose a knowledge perspective of user participation and identify two types of knowledge interactions between user participants and system developers, knowledge acquisition and knowledge exploitation, as main team processes that mediate the relationship between user participation and team performance. In addition, I assimilate recent advances in the filed of collective cognition. Major implications of this study are that user participation may not be effective if participants cannot contribute knowledge to the ISD process, or their knowledge cannot be successfully acquired and utilized by the ISD project team; and team cognition, specified here as transactive memory systems and shared mental models, will shape the effects of knowledge interactions between users and system developers, thereby indirectly influencing the performance of the ISD project team. A theoretical model is also provided.},
	urldate = {2018-03-20},
	booktitle = {Proceedings of the 2004 {SIGMIS} {Conference} on {Computer} {Personnel} {Research}: {Careers}, {Culture}, and {Ethics} in a {Networked} {Environment}},
	publisher = {ACM},
	author = {He, Jun},
	year = {2004},
	keywords = {information systems development, knowledge process, team cognition, team mental models, transactive memory systems, user participation},
	pages = {1--7},
	file = {ACM Full Text PDF:/Users/Felix/Zotero/storage/74FARV89/He - 2004 - Knowledge Impacts of User Participation A Cogniti.pdf:application/pdf}
}